
Blink.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800100  00000bac  00000c40  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000bac  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000165  00800120  00800120  00000c60  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000c60  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000c90  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003f0  00000000  00000000  00000cd0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a069  00000000  00000000  000010c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001d44  00000000  00000000  0000b129  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000022e2  00000000  00000000  0000ce6d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000ad4  00000000  00000000  0000f150  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000026d1  00000000  00000000  0000fc24  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003a1e  00000000  00000000  000122f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000380  00000000  00000000  00015d13  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 5e 00 	jmp	0xbc	; 0xbc <__ctors_end>
   4:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
   8:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
   c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  10:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  14:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  18:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  1c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  20:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  24:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  28:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  2c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  30:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  34:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  38:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  3c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  40:	0c 94 ee 02 	jmp	0x5dc	; 0x5dc <__vector_16>
  44:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  48:	0c 94 78 01 	jmp	0x2f0	; 0x2f0 <__vector_18>
  4c:	0c 94 b0 01 	jmp	0x360	; 0x360 <__vector_19>
  50:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  54:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  58:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  5c:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>
  60:	0c 94 a1 04 	jmp	0x942	; 0x942 <__vector_24>
  64:	0c 94 86 00 	jmp	0x10c	; 0x10c <__bad_interrupt>

00000068 <__trampolines_end>:
  68:	00 00       	nop
  6a:	00 08       	sbc	r0, r0
  6c:	00 02       	muls	r16, r16
  6e:	01 00       	.word	0x0001	; ????
  70:	00 03       	mulsu	r16, r16
  72:	04 07       	cpc	r16, r20
	...

0000007c <digital_pin_to_bit_mask_PGM>:
  7c:	01 02 04 08 10 20 40 80 01 02 04 08 10 20 01 02     ..... @...... ..
  8c:	04 08 10 20                                         ... 

00000090 <digital_pin_to_port_PGM>:
  90:	04 04 04 04 04 04 04 04 02 02 02 02 02 02 03 03     ................
  a0:	03 03 03 03                                         ....

000000a4 <port_to_output_PGM>:
  a4:	00 00 00 00 25 00 28 00 2b 00                       ....%.(.+.

000000ae <port_to_mode_PGM>:
  ae:	00 00 00 00 24 00 27 00 2a 00                       ....$.'.*.

000000b8 <__ctors_start>:
  b8:	e0 01       	movw	r28, r0
  ba:	e9 02       	muls	r30, r25

000000bc <__ctors_end>:
  bc:	11 24       	eor	r1, r1
  be:	1f be       	out	0x3f, r1	; 63
  c0:	cf ef       	ldi	r28, 0xFF	; 255
  c2:	d8 e0       	ldi	r29, 0x08	; 8
  c4:	de bf       	out	0x3e, r29	; 62
  c6:	cd bf       	out	0x3d, r28	; 61

000000c8 <__do_copy_data>:
  c8:	11 e0       	ldi	r17, 0x01	; 1
  ca:	a0 e0       	ldi	r26, 0x00	; 0
  cc:	b1 e0       	ldi	r27, 0x01	; 1
  ce:	ec ea       	ldi	r30, 0xAC	; 172
  d0:	fb e0       	ldi	r31, 0x0B	; 11
  d2:	02 c0       	rjmp	.+4      	; 0xd8 <__do_copy_data+0x10>
  d4:	05 90       	lpm	r0, Z+
  d6:	0d 92       	st	X+, r0
  d8:	a0 32       	cpi	r26, 0x20	; 32
  da:	b1 07       	cpc	r27, r17
  dc:	d9 f7       	brne	.-10     	; 0xd4 <__do_copy_data+0xc>

000000de <__do_clear_bss>:
  de:	22 e0       	ldi	r18, 0x02	; 2
  e0:	a0 e2       	ldi	r26, 0x20	; 32
  e2:	b1 e0       	ldi	r27, 0x01	; 1
  e4:	01 c0       	rjmp	.+2      	; 0xe8 <.do_clear_bss_start>

000000e6 <.do_clear_bss_loop>:
  e6:	1d 92       	st	X+, r1

000000e8 <.do_clear_bss_start>:
  e8:	a5 38       	cpi	r26, 0x85	; 133
  ea:	b2 07       	cpc	r27, r18
  ec:	e1 f7       	brne	.-8      	; 0xe6 <.do_clear_bss_loop>

000000ee <__do_global_ctors>:
  ee:	10 e0       	ldi	r17, 0x00	; 0
  f0:	ce e5       	ldi	r28, 0x5E	; 94
  f2:	d0 e0       	ldi	r29, 0x00	; 0
  f4:	04 c0       	rjmp	.+8      	; 0xfe <__do_global_ctors+0x10>
  f6:	21 97       	sbiw	r28, 0x01	; 1
  f8:	fe 01       	movw	r30, r28
  fa:	0e 94 ce 05 	call	0xb9c	; 0xb9c <__tablejump2__>
  fe:	cc 35       	cpi	r28, 0x5C	; 92
 100:	d1 07       	cpc	r29, r17
 102:	c9 f7       	brne	.-14     	; 0xf6 <__do_global_ctors+0x8>
 104:	0e 94 0e 02 	call	0x41c	; 0x41c <main>
 108:	0c 94 d4 05 	jmp	0xba8	; 0xba8 <_exit>

0000010c <__bad_interrupt>:
 10c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000110 <setup>:


// the setup function runs once when you press reset or power the board
void setup() {
  // initialize digital pin LED_BUILTIN as an output.
  pinMode(LED_BUILTIN, OUTPUT);
 110:	61 e0       	ldi	r22, 0x01	; 1
 112:	8d e0       	ldi	r24, 0x0D	; 13
 114:	0c 94 fd 03 	jmp	0x7fa	; 0x7fa <pinMode>

00000118 <loop>:
}

// the loop function runs over and over again forever
void loop() {
  digitalWrite(LED_BUILTIN, HIGH);   // turn the LED on (HIGH is the voltage level)
 118:	61 e0       	ldi	r22, 0x01	; 1
 11a:	8d e0       	ldi	r24, 0x0D	; 13
 11c:	0e 94 39 04 	call	0x872	; 0x872 <digitalWrite>
  delay(1000);                       // wait for a second
 120:	68 ee       	ldi	r22, 0xE8	; 232
 122:	73 e0       	ldi	r23, 0x03	; 3
 124:	80 e0       	ldi	r24, 0x00	; 0
 126:	90 e0       	ldi	r25, 0x00	; 0
 128:	0e 94 5d 03 	call	0x6ba	; 0x6ba <delay>
  digitalWrite(LED_BUILTIN, LOW);    // turn the LED off by making the voltage LOW
 12c:	60 e0       	ldi	r22, 0x00	; 0
 12e:	8d e0       	ldi	r24, 0x0D	; 13
 130:	0e 94 39 04 	call	0x872	; 0x872 <digitalWrite>
  delay(1000);                       // wait for a second
 134:	68 ee       	ldi	r22, 0xE8	; 232
 136:	73 e0       	ldi	r23, 0x03	; 3
 138:	80 e0       	ldi	r24, 0x00	; 0
 13a:	90 e0       	ldi	r25, 0x00	; 0
 13c:	0c 94 5d 03 	jmp	0x6ba	; 0x6ba <delay>

00000140 <_ZN14HardwareSerial9availableEv>:
  // clear any received data
  _rx_buffer_head = _rx_buffer_tail;
}

int HardwareSerial::available(void)
{
 140:	fc 01       	movw	r30, r24
  return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) % SERIAL_RX_BUFFER_SIZE;
 142:	91 8d       	ldd	r25, Z+25	; 0x19
 144:	22 8d       	ldd	r18, Z+26	; 0x1a
 146:	89 2f       	mov	r24, r25
 148:	90 e0       	ldi	r25, 0x00	; 0
 14a:	80 5c       	subi	r24, 0xC0	; 192
 14c:	9f 4f       	sbci	r25, 0xFF	; 255
 14e:	82 1b       	sub	r24, r18
 150:	91 09       	sbc	r25, r1
}
 152:	8f 73       	andi	r24, 0x3F	; 63
 154:	99 27       	eor	r25, r25
 156:	08 95       	ret

00000158 <_ZN14HardwareSerial4peekEv>:

int HardwareSerial::peek(void)
{
 158:	fc 01       	movw	r30, r24
  if (_rx_buffer_head == _rx_buffer_tail) {
 15a:	91 8d       	ldd	r25, Z+25	; 0x19
 15c:	82 8d       	ldd	r24, Z+26	; 0x1a
 15e:	98 17       	cp	r25, r24
 160:	31 f0       	breq	.+12     	; 0x16e <_ZN14HardwareSerial4peekEv+0x16>
    return -1;
  } else {
    return _rx_buffer[_rx_buffer_tail];
 162:	82 8d       	ldd	r24, Z+26	; 0x1a
 164:	e8 0f       	add	r30, r24
 166:	f1 1d       	adc	r31, r1
 168:	85 8d       	ldd	r24, Z+29	; 0x1d
 16a:	90 e0       	ldi	r25, 0x00	; 0
 16c:	08 95       	ret
}

int HardwareSerial::peek(void)
{
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 16e:	8f ef       	ldi	r24, 0xFF	; 255
 170:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    return _rx_buffer[_rx_buffer_tail];
  }
}
 172:	08 95       	ret

00000174 <_ZN14HardwareSerial4readEv>:

int HardwareSerial::read(void)
{
 174:	fc 01       	movw	r30, r24
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
 176:	91 8d       	ldd	r25, Z+25	; 0x19
 178:	82 8d       	ldd	r24, Z+26	; 0x1a
 17a:	98 17       	cp	r25, r24
 17c:	61 f0       	breq	.+24     	; 0x196 <_ZN14HardwareSerial4readEv+0x22>
    return -1;
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
 17e:	82 8d       	ldd	r24, Z+26	; 0x1a
 180:	df 01       	movw	r26, r30
 182:	a8 0f       	add	r26, r24
 184:	b1 1d       	adc	r27, r1
 186:	5d 96       	adiw	r26, 0x1d	; 29
 188:	8c 91       	ld	r24, X
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
 18a:	92 8d       	ldd	r25, Z+26	; 0x1a
 18c:	9f 5f       	subi	r25, 0xFF	; 255
 18e:	9f 73       	andi	r25, 0x3F	; 63
 190:	92 8f       	std	Z+26, r25	; 0x1a
    return c;
 192:	90 e0       	ldi	r25, 0x00	; 0
 194:	08 95       	ret

int HardwareSerial::read(void)
{
  // if the head isn't ahead of the tail, we don't have any characters
  if (_rx_buffer_head == _rx_buffer_tail) {
    return -1;
 196:	8f ef       	ldi	r24, 0xFF	; 255
 198:	9f ef       	ldi	r25, 0xFF	; 255
  } else {
    unsigned char c = _rx_buffer[_rx_buffer_tail];
    _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) % SERIAL_RX_BUFFER_SIZE;
    return c;
  }
}
 19a:	08 95       	ret

0000019c <_Z14serialEventRunv>:
#endif

void serialEventRun(void)
{
#if defined(HAVE_HWSERIAL0)
  if (Serial0_available && serialEvent && Serial0_available()) serialEvent();
 19c:	86 ed       	ldi	r24, 0xD6	; 214
 19e:	91 e0       	ldi	r25, 0x01	; 1
 1a0:	89 2b       	or	r24, r25
 1a2:	49 f0       	breq	.+18     	; 0x1b6 <_Z14serialEventRunv+0x1a>
 1a4:	80 e0       	ldi	r24, 0x00	; 0
 1a6:	90 e0       	ldi	r25, 0x00	; 0
 1a8:	89 2b       	or	r24, r25
 1aa:	29 f0       	breq	.+10     	; 0x1b6 <_Z14serialEventRunv+0x1a>
 1ac:	0e 94 d6 01 	call	0x3ac	; 0x3ac <_Z17Serial0_availablev>
 1b0:	81 11       	cpse	r24, r1
 1b2:	0e 94 00 00 	call	0	; 0x0 <__vectors>
 1b6:	08 95       	ret

000001b8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>:
}

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_tx_udr_empty_irq(void)
{
 1b8:	fc 01       	movw	r30, r24
  // If interrupts are enabled, there must be more data in the output
  // buffer. Send the next byte
  unsigned char c = _tx_buffer[_tx_buffer_tail];
 1ba:	84 8d       	ldd	r24, Z+28	; 0x1c
 1bc:	df 01       	movw	r26, r30
 1be:	a8 0f       	add	r26, r24
 1c0:	b1 1d       	adc	r27, r1
 1c2:	a3 5a       	subi	r26, 0xA3	; 163
 1c4:	bf 4f       	sbci	r27, 0xFF	; 255
 1c6:	8c 91       	ld	r24, X
  _tx_buffer_tail = (_tx_buffer_tail + 1) % SERIAL_TX_BUFFER_SIZE;
 1c8:	24 8d       	ldd	r18, Z+28	; 0x1c
 1ca:	30 e0       	ldi	r19, 0x00	; 0
 1cc:	2f 5f       	subi	r18, 0xFF	; 255
 1ce:	3f 4f       	sbci	r19, 0xFF	; 255
 1d0:	2f 73       	andi	r18, 0x3F	; 63
 1d2:	30 78       	andi	r19, 0x80	; 128
 1d4:	33 23       	and	r19, r19
 1d6:	34 f4       	brge	.+12     	; 0x1e4 <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x2c>
 1d8:	21 50       	subi	r18, 0x01	; 1
 1da:	31 09       	sbc	r19, r1
 1dc:	20 6c       	ori	r18, 0xC0	; 192
 1de:	3f 6f       	ori	r19, 0xFF	; 255
 1e0:	2f 5f       	subi	r18, 0xFF	; 255
 1e2:	3f 4f       	sbci	r19, 0xFF	; 255
 1e4:	24 8f       	std	Z+28, r18	; 0x1c

  *_udr = c;
 1e6:	a6 89       	ldd	r26, Z+22	; 0x16
 1e8:	b7 89       	ldd	r27, Z+23	; 0x17
 1ea:	8c 93       	st	X, r24

  // clear the TXC bit -- "can be cleared by writing a one to its bit
  // location". This makes sure flush() won't return until the bytes
  // actually got written
  sbi(*_ucsra, TXC0);
 1ec:	a0 89       	ldd	r26, Z+16	; 0x10
 1ee:	b1 89       	ldd	r27, Z+17	; 0x11
 1f0:	8c 91       	ld	r24, X
 1f2:	80 64       	ori	r24, 0x40	; 64
 1f4:	8c 93       	st	X, r24

  if (_tx_buffer_head == _tx_buffer_tail) {
 1f6:	93 8d       	ldd	r25, Z+27	; 0x1b
 1f8:	84 8d       	ldd	r24, Z+28	; 0x1c
 1fa:	98 13       	cpse	r25, r24
 1fc:	06 c0       	rjmp	.+12     	; 0x20a <_ZN14HardwareSerial17_tx_udr_empty_irqEv+0x52>
    // Buffer empty, so disable interrupts
    cbi(*_ucsrb, UDRIE0);
 1fe:	02 88       	ldd	r0, Z+18	; 0x12
 200:	f3 89       	ldd	r31, Z+19	; 0x13
 202:	e0 2d       	mov	r30, r0
 204:	80 81       	ld	r24, Z
 206:	8f 7d       	andi	r24, 0xDF	; 223
 208:	80 83       	st	Z, r24
 20a:	08 95       	ret

0000020c <_ZN14HardwareSerial5flushEv>:
  if (head >= tail) return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
  return tail - head - 1;
}

void HardwareSerial::flush()
{
 20c:	cf 93       	push	r28
 20e:	df 93       	push	r29
 210:	ec 01       	movw	r28, r24
  // If we have never written a byte, no need to flush. This special
  // case is needed since there is no way to force the TXC (transmit
  // complete) bit to 1 during initialization
  if (!_written)
 212:	88 8d       	ldd	r24, Y+24	; 0x18
 214:	88 23       	and	r24, r24
 216:	d9 f0       	breq	.+54     	; 0x24e <_ZN14HardwareSerial5flushEv+0x42>
    return;

  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
 218:	ea 89       	ldd	r30, Y+18	; 0x12
 21a:	fb 89       	ldd	r31, Y+19	; 0x13
 21c:	80 81       	ld	r24, Z
 21e:	85 fd       	sbrc	r24, 5
 220:	05 c0       	rjmp	.+10     	; 0x22c <_ZN14HardwareSerial5flushEv+0x20>
 222:	a8 89       	ldd	r26, Y+16	; 0x10
 224:	b9 89       	ldd	r27, Y+17	; 0x11
 226:	8c 91       	ld	r24, X
 228:	86 fd       	sbrc	r24, 6
 22a:	11 c0       	rjmp	.+34     	; 0x24e <_ZN14HardwareSerial5flushEv+0x42>
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
 22c:	0f b6       	in	r0, 0x3f	; 63
 22e:	07 fc       	sbrc	r0, 7
 230:	f5 cf       	rjmp	.-22     	; 0x21c <_ZN14HardwareSerial5flushEv+0x10>
 232:	80 81       	ld	r24, Z
 234:	85 ff       	sbrs	r24, 5
 236:	f2 cf       	rjmp	.-28     	; 0x21c <_ZN14HardwareSerial5flushEv+0x10>
 238:	04 c0       	rjmp	.+8      	; 0x242 <_ZN14HardwareSerial5flushEv+0x36>
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
	  _tx_udr_empty_irq();
 23a:	ce 01       	movw	r24, r28
 23c:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
 240:	eb cf       	rjmp	.-42     	; 0x218 <_ZN14HardwareSerial5flushEv+0xc>
  while (bit_is_set(*_ucsrb, UDRIE0) || bit_is_clear(*_ucsra, TXC0)) {
    if (bit_is_clear(SREG, SREG_I) && bit_is_set(*_ucsrb, UDRIE0))
	// Interrupts are globally disabled, but the DR empty
	// interrupt should be enabled, so poll the DR empty flag to
	// prevent deadlock
	if (bit_is_set(*_ucsra, UDRE0))
 242:	a8 89       	ldd	r26, Y+16	; 0x10
 244:	b9 89       	ldd	r27, Y+17	; 0x11
 246:	8c 91       	ld	r24, X
 248:	85 ff       	sbrs	r24, 5
 24a:	e8 cf       	rjmp	.-48     	; 0x21c <_ZN14HardwareSerial5flushEv+0x10>
 24c:	f6 cf       	rjmp	.-20     	; 0x23a <_ZN14HardwareSerial5flushEv+0x2e>
	  _tx_udr_empty_irq();
  }
  // If we get here, nothing is queued anymore (DRIE is disabled) and
  // the hardware finished tranmission (TXC is set).
}
 24e:	df 91       	pop	r29
 250:	cf 91       	pop	r28
 252:	08 95       	ret

00000254 <_ZN14HardwareSerial5writeEh>:

size_t HardwareSerial::write(uint8_t c)
{
 254:	0f 93       	push	r16
 256:	1f 93       	push	r17
 258:	cf 93       	push	r28
 25a:	df 93       	push	r29
 25c:	ec 01       	movw	r28, r24
  _written = true;
 25e:	81 e0       	ldi	r24, 0x01	; 1
 260:	88 8f       	std	Y+24, r24	; 0x18
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
 262:	9b 8d       	ldd	r25, Y+27	; 0x1b
 264:	8c 8d       	ldd	r24, Y+28	; 0x1c
 266:	98 13       	cpse	r25, r24
 268:	23 c0       	rjmp	.+70     	; 0x2b0 <_ZN14HardwareSerial5writeEh+0x5c>
 26a:	e8 89       	ldd	r30, Y+16	; 0x10
 26c:	f9 89       	ldd	r31, Y+17	; 0x11
 26e:	80 81       	ld	r24, Z
 270:	85 fd       	sbrc	r24, 5
 272:	2f c0       	rjmp	.+94     	; 0x2d2 <_ZN14HardwareSerial5writeEh+0x7e>
 274:	1d c0       	rjmp	.+58     	; 0x2b0 <_ZN14HardwareSerial5writeEh+0x5c>
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
	
  // If the output buffer is full, there's nothing for it other than to 
  // wait for the interrupt handler to empty it a bit
  while (i == _tx_buffer_tail) {
 276:	9c 8d       	ldd	r25, Y+28	; 0x1c
 278:	19 13       	cpse	r17, r25
 27a:	0c c0       	rjmp	.+24     	; 0x294 <_ZN14HardwareSerial5writeEh+0x40>
    if (bit_is_clear(SREG, SREG_I)) {
 27c:	0f b6       	in	r0, 0x3f	; 63
 27e:	07 fc       	sbrc	r0, 7
 280:	fa cf       	rjmp	.-12     	; 0x276 <_ZN14HardwareSerial5writeEh+0x22>
      // Interrupts are disabled, so we'll have to poll the data
      // register empty flag ourselves. If it is set, pretend an
      // interrupt has happened and call the handler to free up
      // space for us.
      if(bit_is_set(*_ucsra, UDRE0))
 282:	e8 89       	ldd	r30, Y+16	; 0x10
 284:	f9 89       	ldd	r31, Y+17	; 0x11
 286:	80 81       	ld	r24, Z
 288:	85 ff       	sbrs	r24, 5
 28a:	f5 cf       	rjmp	.-22     	; 0x276 <_ZN14HardwareSerial5writeEh+0x22>
	_tx_udr_empty_irq();
 28c:	ce 01       	movw	r24, r28
 28e:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
 292:	f1 cf       	rjmp	.-30     	; 0x276 <_ZN14HardwareSerial5writeEh+0x22>
    } else {
      // nop, the interrupt handler will free up space for us
    }
  }

  _tx_buffer[_tx_buffer_head] = c;
 294:	8b 8d       	ldd	r24, Y+27	; 0x1b
 296:	fe 01       	movw	r30, r28
 298:	e8 0f       	add	r30, r24
 29a:	f1 1d       	adc	r31, r1
 29c:	e3 5a       	subi	r30, 0xA3	; 163
 29e:	ff 4f       	sbci	r31, 0xFF	; 255
 2a0:	00 83       	st	Z, r16
  _tx_buffer_head = i;
 2a2:	1b 8f       	std	Y+27, r17	; 0x1b
	
  sbi(*_ucsrb, UDRIE0);
 2a4:	ea 89       	ldd	r30, Y+18	; 0x12
 2a6:	fb 89       	ldd	r31, Y+19	; 0x13
 2a8:	80 81       	ld	r24, Z
 2aa:	80 62       	ori	r24, 0x20	; 32
 2ac:	80 83       	st	Z, r24
  
  return 1;
 2ae:	19 c0       	rjmp	.+50     	; 0x2e2 <_ZN14HardwareSerial5writeEh+0x8e>
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
    sbi(*_ucsra, TXC0);
    return 1;
  }
  tx_buffer_index_t i = (_tx_buffer_head + 1) % SERIAL_TX_BUFFER_SIZE;
 2b0:	2b 8d       	ldd	r18, Y+27	; 0x1b
 2b2:	30 e0       	ldi	r19, 0x00	; 0
 2b4:	2f 5f       	subi	r18, 0xFF	; 255
 2b6:	3f 4f       	sbci	r19, 0xFF	; 255
 2b8:	2f 73       	andi	r18, 0x3F	; 63
 2ba:	30 78       	andi	r19, 0x80	; 128
 2bc:	33 23       	and	r19, r19
 2be:	34 f4       	brge	.+12     	; 0x2cc <_ZN14HardwareSerial5writeEh+0x78>
 2c0:	21 50       	subi	r18, 0x01	; 1
 2c2:	31 09       	sbc	r19, r1
 2c4:	20 6c       	ori	r18, 0xC0	; 192
 2c6:	3f 6f       	ori	r19, 0xFF	; 255
 2c8:	2f 5f       	subi	r18, 0xFF	; 255
 2ca:	3f 4f       	sbci	r19, 0xFF	; 255
 2cc:	06 2f       	mov	r16, r22
 2ce:	12 2f       	mov	r17, r18
 2d0:	d2 cf       	rjmp	.-92     	; 0x276 <_ZN14HardwareSerial5writeEh+0x22>
  // If the buffer and the data register is empty, just write the byte
  // to the data register and be done. This shortcut helps
  // significantly improve the effective datarate at high (>
  // 500kbit/s) bitrates, where interrupt overhead becomes a slowdown.
  if (_tx_buffer_head == _tx_buffer_tail && bit_is_set(*_ucsra, UDRE0)) {
    *_udr = c;
 2d2:	ee 89       	ldd	r30, Y+22	; 0x16
 2d4:	ff 89       	ldd	r31, Y+23	; 0x17
 2d6:	60 83       	st	Z, r22
    sbi(*_ucsra, TXC0);
 2d8:	e8 89       	ldd	r30, Y+16	; 0x10
 2da:	f9 89       	ldd	r31, Y+17	; 0x11
 2dc:	80 81       	ld	r24, Z
 2de:	80 64       	ori	r24, 0x40	; 64
 2e0:	80 83       	st	Z, r24
  _tx_buffer_head = i;
	
  sbi(*_ucsrb, UDRIE0);
  
  return 1;
}
 2e2:	81 e0       	ldi	r24, 0x01	; 1
 2e4:	90 e0       	ldi	r25, 0x00	; 0
 2e6:	df 91       	pop	r29
 2e8:	cf 91       	pop	r28
 2ea:	1f 91       	pop	r17
 2ec:	0f 91       	pop	r16
 2ee:	08 95       	ret

000002f0 <__vector_18>:
#elif defined(USART_RXC_vect)
  ISR(USART_RXC_vect) // ATmega8
#else
  #error "Don't know what the Data Received vector is called for Serial"
#endif
  {
 2f0:	1f 92       	push	r1
 2f2:	0f 92       	push	r0
 2f4:	0f b6       	in	r0, 0x3f	; 63
 2f6:	0f 92       	push	r0
 2f8:	11 24       	eor	r1, r1
 2fa:	2f 93       	push	r18
 2fc:	8f 93       	push	r24
 2fe:	9f 93       	push	r25
 300:	af 93       	push	r26
 302:	bf 93       	push	r27
 304:	ef 93       	push	r30
 306:	ff 93       	push	r31

// Actual interrupt handlers //////////////////////////////////////////////////////////////

void HardwareSerial::_rx_complete_irq(void)
{
  if (bit_is_clear(*_ucsra, UPE0)) {
 308:	e0 91 30 01 	lds	r30, 0x0130	; 0x800130 <__data_end+0x10>
 30c:	f0 91 31 01 	lds	r31, 0x0131	; 0x800131 <__data_end+0x11>
 310:	80 81       	ld	r24, Z
 312:	82 fd       	sbrc	r24, 2
 314:	14 c0       	rjmp	.+40     	; 0x33e <__vector_18+0x4e>
    // No Parity error, read byte and store it in the buffer if there is
    // room
    unsigned char c = *_udr;
 316:	e0 e2       	ldi	r30, 0x20	; 32
 318:	f1 e0       	ldi	r31, 0x01	; 1
 31a:	a6 89       	ldd	r26, Z+22	; 0x16
 31c:	b7 89       	ldd	r27, Z+23	; 0x17
 31e:	2c 91       	ld	r18, X
    rx_buffer_index_t i = (unsigned int)(_rx_buffer_head + 1) % SERIAL_RX_BUFFER_SIZE;
 320:	81 8d       	ldd	r24, Z+25	; 0x19
 322:	8f 5f       	subi	r24, 0xFF	; 255
 324:	8f 73       	andi	r24, 0x3F	; 63

    // if we should be storing the received character into the location
    // just before the tail (meaning that the head would advance to the
    // current location of the tail), we're about to overflow the buffer
    // and so we don't write the character or advance the head.
    if (i != _rx_buffer_tail) {
 326:	92 8d       	ldd	r25, Z+26	; 0x1a
 328:	89 17       	cp	r24, r25
 32a:	71 f0       	breq	.+28     	; 0x348 <__vector_18+0x58>
      _rx_buffer[_rx_buffer_head] = c;
 32c:	df 01       	movw	r26, r30
 32e:	e1 8d       	ldd	r30, Z+25	; 0x19
 330:	f0 e0       	ldi	r31, 0x00	; 0
 332:	e0 5e       	subi	r30, 0xE0	; 224
 334:	fe 4f       	sbci	r31, 0xFE	; 254
 336:	25 8f       	std	Z+29, r18	; 0x1d
      _rx_buffer_head = i;
 338:	59 96       	adiw	r26, 0x19	; 25
 33a:	8c 93       	st	X, r24
 33c:	05 c0       	rjmp	.+10     	; 0x348 <__vector_18+0x58>
    }
  } else {
    // Parity error, read byte but discard it
    *_udr;
 33e:	e0 91 36 01 	lds	r30, 0x0136	; 0x800136 <__data_end+0x16>
 342:	f0 91 37 01 	lds	r31, 0x0137	; 0x800137 <__data_end+0x17>
 346:	80 81       	ld	r24, Z
    Serial._rx_complete_irq();
  }
 348:	ff 91       	pop	r31
 34a:	ef 91       	pop	r30
 34c:	bf 91       	pop	r27
 34e:	af 91       	pop	r26
 350:	9f 91       	pop	r25
 352:	8f 91       	pop	r24
 354:	2f 91       	pop	r18
 356:	0f 90       	pop	r0
 358:	0f be       	out	0x3f, r0	; 63
 35a:	0f 90       	pop	r0
 35c:	1f 90       	pop	r1
 35e:	18 95       	reti

00000360 <__vector_19>:
#elif defined(USART_UDRE_vect)
ISR(USART_UDRE_vect)
#else
  #error "Don't know what the Data Register Empty vector is called for Serial"
#endif
{
 360:	1f 92       	push	r1
 362:	0f 92       	push	r0
 364:	0f b6       	in	r0, 0x3f	; 63
 366:	0f 92       	push	r0
 368:	11 24       	eor	r1, r1
 36a:	2f 93       	push	r18
 36c:	3f 93       	push	r19
 36e:	4f 93       	push	r20
 370:	5f 93       	push	r21
 372:	6f 93       	push	r22
 374:	7f 93       	push	r23
 376:	8f 93       	push	r24
 378:	9f 93       	push	r25
 37a:	af 93       	push	r26
 37c:	bf 93       	push	r27
 37e:	ef 93       	push	r30
 380:	ff 93       	push	r31
  Serial._tx_udr_empty_irq();
 382:	80 e2       	ldi	r24, 0x20	; 32
 384:	91 e0       	ldi	r25, 0x01	; 1
 386:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <_ZN14HardwareSerial17_tx_udr_empty_irqEv>
}
 38a:	ff 91       	pop	r31
 38c:	ef 91       	pop	r30
 38e:	bf 91       	pop	r27
 390:	af 91       	pop	r26
 392:	9f 91       	pop	r25
 394:	8f 91       	pop	r24
 396:	7f 91       	pop	r23
 398:	6f 91       	pop	r22
 39a:	5f 91       	pop	r21
 39c:	4f 91       	pop	r20
 39e:	3f 91       	pop	r19
 3a0:	2f 91       	pop	r18
 3a2:	0f 90       	pop	r0
 3a4:	0f be       	out	0x3f, r0	; 63
 3a6:	0f 90       	pop	r0
 3a8:	1f 90       	pop	r1
 3aa:	18 95       	reti

000003ac <_Z17Serial0_availablev>:
#endif

// Function that can be weakly referenced by serialEventRun to prevent
// pulling in this file if it's not otherwise used.
bool Serial0_available() {
  return Serial.available();
 3ac:	80 e2       	ldi	r24, 0x20	; 32
 3ae:	91 e0       	ldi	r25, 0x01	; 1
 3b0:	0e 94 a0 00 	call	0x140	; 0x140 <_ZN14HardwareSerial9availableEv>
 3b4:	21 e0       	ldi	r18, 0x01	; 1
 3b6:	89 2b       	or	r24, r25
 3b8:	09 f4       	brne	.+2      	; 0x3bc <_Z17Serial0_availablev+0x10>
 3ba:	20 e0       	ldi	r18, 0x00	; 0
}
 3bc:	82 2f       	mov	r24, r18
 3be:	08 95       	ret

000003c0 <_GLOBAL__sub_I___vector_18>:
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
  public:
    Print() : write_error(0) {}
 3c0:	e0 e2       	ldi	r30, 0x20	; 32
 3c2:	f1 e0       	ldi	r31, 0x01	; 1
 3c4:	13 82       	std	Z+3, r1	; 0x03
 3c6:	12 82       	std	Z+2, r1	; 0x02
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 3c8:	88 ee       	ldi	r24, 0xE8	; 232
 3ca:	93 e0       	ldi	r25, 0x03	; 3
 3cc:	a0 e0       	ldi	r26, 0x00	; 0
 3ce:	b0 e0       	ldi	r27, 0x00	; 0
 3d0:	84 83       	std	Z+4, r24	; 0x04
 3d2:	95 83       	std	Z+5, r25	; 0x05
 3d4:	a6 83       	std	Z+6, r26	; 0x06
 3d6:	b7 83       	std	Z+7, r27	; 0x07
  volatile uint8_t *ucsrc, volatile uint8_t *udr) :
    _ubrrh(ubrrh), _ubrrl(ubrrl),
    _ucsra(ucsra), _ucsrb(ucsrb), _ucsrc(ucsrc),
    _udr(udr),
    _rx_buffer_head(0), _rx_buffer_tail(0),
    _tx_buffer_head(0), _tx_buffer_tail(0)
 3d8:	84 e0       	ldi	r24, 0x04	; 4
 3da:	91 e0       	ldi	r25, 0x01	; 1
 3dc:	91 83       	std	Z+1, r25	; 0x01
 3de:	80 83       	st	Z, r24
 3e0:	85 ec       	ldi	r24, 0xC5	; 197
 3e2:	90 e0       	ldi	r25, 0x00	; 0
 3e4:	95 87       	std	Z+13, r25	; 0x0d
 3e6:	84 87       	std	Z+12, r24	; 0x0c
 3e8:	84 ec       	ldi	r24, 0xC4	; 196
 3ea:	90 e0       	ldi	r25, 0x00	; 0
 3ec:	97 87       	std	Z+15, r25	; 0x0f
 3ee:	86 87       	std	Z+14, r24	; 0x0e
 3f0:	80 ec       	ldi	r24, 0xC0	; 192
 3f2:	90 e0       	ldi	r25, 0x00	; 0
 3f4:	91 8b       	std	Z+17, r25	; 0x11
 3f6:	80 8b       	std	Z+16, r24	; 0x10
 3f8:	81 ec       	ldi	r24, 0xC1	; 193
 3fa:	90 e0       	ldi	r25, 0x00	; 0
 3fc:	93 8b       	std	Z+19, r25	; 0x13
 3fe:	82 8b       	std	Z+18, r24	; 0x12
 400:	82 ec       	ldi	r24, 0xC2	; 194
 402:	90 e0       	ldi	r25, 0x00	; 0
 404:	95 8b       	std	Z+21, r25	; 0x15
 406:	84 8b       	std	Z+20, r24	; 0x14
 408:	86 ec       	ldi	r24, 0xC6	; 198
 40a:	90 e0       	ldi	r25, 0x00	; 0
 40c:	97 8b       	std	Z+23, r25	; 0x17
 40e:	86 8b       	std	Z+22, r24	; 0x16
 410:	11 8e       	std	Z+25, r1	; 0x19
 412:	12 8e       	std	Z+26, r1	; 0x1a
 414:	13 8e       	std	Z+27, r1	; 0x1b
 416:	14 8e       	std	Z+28, r1	; 0x1c
 418:	08 95       	ret

0000041a <initVariant>:
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }

void setupUSB() __attribute__((weak));
void setupUSB() { }
 41a:	08 95       	ret

0000041c <main>:

int main(void)
{
	init();
 41c:	0e 94 99 03 	call	0x732	; 0x732 <init>

	initVariant();
 420:	0e 94 0d 02 	call	0x41a	; 0x41a <initVariant>

#if defined(USBCON)
	USBDevice.attach();
#endif
	
	setup();
 424:	0e 94 88 00 	call	0x110	; 0x110 <setup>
    
	for (;;) {
		loop();
		if (serialEventRun) serialEventRun();
 428:	ce ec       	ldi	r28, 0xCE	; 206
 42a:	d0 e0       	ldi	r29, 0x00	; 0
#endif
	
	setup();
    
	for (;;) {
		loop();
 42c:	0e 94 8c 00 	call	0x118	; 0x118 <loop>
		if (serialEventRun) serialEventRun();
 430:	20 97       	sbiw	r28, 0x00	; 0
 432:	e1 f3       	breq	.-8      	; 0x42c <main+0x10>
 434:	0e 94 ce 00 	call	0x19c	; 0x19c <_Z14serialEventRunv>
 438:	f9 cf       	rjmp	.-14     	; 0x42c <main+0x10>

0000043a <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 43a:	cf 92       	push	r12
 43c:	df 92       	push	r13
 43e:	ef 92       	push	r14
 440:	ff 92       	push	r15
 442:	0f 93       	push	r16
 444:	1f 93       	push	r17
 446:	cf 93       	push	r28
 448:	df 93       	push	r29
  size_t n = 0;
  while (size--) {
 44a:	41 15       	cp	r20, r1
 44c:	51 05       	cpc	r21, r1
 44e:	c1 f0       	breq	.+48     	; 0x480 <_ZN5Print5writeEPKhj+0x46>
 450:	6a 01       	movw	r12, r20
 452:	8c 01       	movw	r16, r24
 454:	e6 2e       	mov	r14, r22
 456:	f7 2e       	mov	r15, r23
 458:	c0 e0       	ldi	r28, 0x00	; 0
 45a:	d0 e0       	ldi	r29, 0x00	; 0
    if (write(*buffer++)) n++;
 45c:	d7 01       	movw	r26, r14
 45e:	6d 91       	ld	r22, X+
 460:	7d 01       	movw	r14, r26
 462:	d8 01       	movw	r26, r16
 464:	ed 91       	ld	r30, X+
 466:	fc 91       	ld	r31, X
 468:	01 90       	ld	r0, Z+
 46a:	f0 81       	ld	r31, Z
 46c:	e0 2d       	mov	r30, r0
 46e:	c8 01       	movw	r24, r16
 470:	09 95       	icall
 472:	89 2b       	or	r24, r25
 474:	39 f0       	breq	.+14     	; 0x484 <_ZN5Print5writeEPKhj+0x4a>
 476:	21 96       	adiw	r28, 0x01	; 1

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
 478:	cc 16       	cp	r12, r28
 47a:	dd 06       	cpc	r13, r29
 47c:	79 f7       	brne	.-34     	; 0x45c <_ZN5Print5writeEPKhj+0x22>
 47e:	02 c0       	rjmp	.+4      	; 0x484 <_ZN5Print5writeEPKhj+0x4a>
// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
 480:	c0 e0       	ldi	r28, 0x00	; 0
 482:	d0 e0       	ldi	r29, 0x00	; 0
  while (size--) {
    if (write(*buffer++)) n++;
    else break;
  }
  return n;
}
 484:	ce 01       	movw	r24, r28
 486:	df 91       	pop	r29
 488:	cf 91       	pop	r28
 48a:	1f 91       	pop	r17
 48c:	0f 91       	pop	r16
 48e:	ff 90       	pop	r15
 490:	ef 90       	pop	r14
 492:	df 90       	pop	r13
 494:	cf 90       	pop	r12
 496:	08 95       	ret

00000498 <_ZN7TwoWire9availableEv>:
}

// sets function called on slave read
void TwoWire::onRequest( void (*function)(void) )
{
  user_onRequest = function;
 498:	80 91 ec 01 	lds	r24, 0x01EC	; 0x8001ec <_ZN7TwoWire14rxBufferLengthE>
 49c:	90 e0       	ldi	r25, 0x00	; 0
 49e:	20 91 ed 01 	lds	r18, 0x01ED	; 0x8001ed <_ZN7TwoWire13rxBufferIndexE>
 4a2:	82 1b       	sub	r24, r18
 4a4:	91 09       	sbc	r25, r1
 4a6:	08 95       	ret

000004a8 <_ZN7TwoWire4readEv>:
 4a8:	90 91 ed 01 	lds	r25, 0x01ED	; 0x8001ed <_ZN7TwoWire13rxBufferIndexE>
 4ac:	80 91 ec 01 	lds	r24, 0x01EC	; 0x8001ec <_ZN7TwoWire14rxBufferLengthE>
 4b0:	98 17       	cp	r25, r24
 4b2:	50 f4       	brcc	.+20     	; 0x4c8 <_ZN7TwoWire4readEv+0x20>
 4b4:	e9 2f       	mov	r30, r25
 4b6:	f0 e0       	ldi	r31, 0x00	; 0
 4b8:	e2 51       	subi	r30, 0x12	; 18
 4ba:	fe 4f       	sbci	r31, 0xFE	; 254
 4bc:	20 81       	ld	r18, Z
 4be:	30 e0       	ldi	r19, 0x00	; 0
 4c0:	9f 5f       	subi	r25, 0xFF	; 255
 4c2:	90 93 ed 01 	sts	0x01ED, r25	; 0x8001ed <_ZN7TwoWire13rxBufferIndexE>
 4c6:	02 c0       	rjmp	.+4      	; 0x4cc <_ZN7TwoWire4readEv+0x24>
 4c8:	2f ef       	ldi	r18, 0xFF	; 255
 4ca:	3f ef       	ldi	r19, 0xFF	; 255
 4cc:	c9 01       	movw	r24, r18
 4ce:	08 95       	ret

000004d0 <_ZN7TwoWire4peekEv>:
 4d0:	e0 91 ed 01 	lds	r30, 0x01ED	; 0x8001ed <_ZN7TwoWire13rxBufferIndexE>
 4d4:	80 91 ec 01 	lds	r24, 0x01EC	; 0x8001ec <_ZN7TwoWire14rxBufferLengthE>
 4d8:	e8 17       	cp	r30, r24
 4da:	30 f4       	brcc	.+12     	; 0x4e8 <_ZN7TwoWire4peekEv+0x18>
 4dc:	f0 e0       	ldi	r31, 0x00	; 0
 4de:	e2 51       	subi	r30, 0x12	; 18
 4e0:	fe 4f       	sbci	r31, 0xFE	; 254
 4e2:	80 81       	ld	r24, Z
 4e4:	90 e0       	ldi	r25, 0x00	; 0
 4e6:	08 95       	ret
 4e8:	8f ef       	ldi	r24, 0xFF	; 255
 4ea:	9f ef       	ldi	r25, 0xFF	; 255
 4ec:	08 95       	ret

000004ee <_ZN7TwoWire5flushEv>:
 4ee:	08 95       	ret

000004f0 <_ZN7TwoWire5writeEPKhj>:
 4f0:	cf 92       	push	r12
 4f2:	df 92       	push	r13
 4f4:	ef 92       	push	r14
 4f6:	ff 92       	push	r15
 4f8:	0f 93       	push	r16
 4fa:	1f 93       	push	r17
 4fc:	cf 93       	push	r28
 4fe:	df 93       	push	r29
 500:	8c 01       	movw	r16, r24
 502:	cb 01       	movw	r24, r22
 504:	6a 01       	movw	r12, r20
 506:	20 91 c9 01 	lds	r18, 0x01C9	; 0x8001c9 <_ZN7TwoWire12transmittingE>
 50a:	22 23       	and	r18, r18
 50c:	a1 f0       	breq	.+40     	; 0x536 <_ZN7TwoWire5writeEPKhj+0x46>
 50e:	41 15       	cp	r20, r1
 510:	51 05       	cpc	r21, r1
 512:	a1 f0       	breq	.+40     	; 0x53c <_ZN7TwoWire5writeEPKhj+0x4c>
 514:	eb 01       	movw	r28, r22
 516:	7b 01       	movw	r14, r22
 518:	e4 0e       	add	r14, r20
 51a:	f5 1e       	adc	r15, r21
 51c:	69 91       	ld	r22, Y+
 51e:	d8 01       	movw	r26, r16
 520:	ed 91       	ld	r30, X+
 522:	fc 91       	ld	r31, X
 524:	01 90       	ld	r0, Z+
 526:	f0 81       	ld	r31, Z
 528:	e0 2d       	mov	r30, r0
 52a:	c8 01       	movw	r24, r16
 52c:	09 95       	icall
 52e:	ce 15       	cp	r28, r14
 530:	df 05       	cpc	r29, r15
 532:	a1 f7       	brne	.-24     	; 0x51c <_ZN7TwoWire5writeEPKhj+0x2c>
 534:	03 c0       	rjmp	.+6      	; 0x53c <_ZN7TwoWire5writeEPKhj+0x4c>
 536:	64 2f       	mov	r22, r20
 538:	0e 94 69 04 	call	0x8d2	; 0x8d2 <twi_transmit>
 53c:	c6 01       	movw	r24, r12
 53e:	df 91       	pop	r29
 540:	cf 91       	pop	r28
 542:	1f 91       	pop	r17
 544:	0f 91       	pop	r16
 546:	ff 90       	pop	r15
 548:	ef 90       	pop	r14
 54a:	df 90       	pop	r13
 54c:	cf 90       	pop	r12
 54e:	08 95       	ret

00000550 <_ZN7TwoWire5writeEh>:
 550:	cf 93       	push	r28
 552:	df 93       	push	r29
 554:	1f 92       	push	r1
 556:	cd b7       	in	r28, 0x3d	; 61
 558:	de b7       	in	r29, 0x3e	; 62
 55a:	fc 01       	movw	r30, r24
 55c:	69 83       	std	Y+1, r22	; 0x01
 55e:	90 91 c9 01 	lds	r25, 0x01C9	; 0x8001c9 <_ZN7TwoWire12transmittingE>
 562:	99 23       	and	r25, r25
 564:	d9 f0       	breq	.+54     	; 0x59c <_ZN7TwoWire5writeEh+0x4c>
 566:	90 91 ca 01 	lds	r25, 0x01CA	; 0x8001ca <_ZN7TwoWire14txBufferLengthE>
 56a:	90 32       	cpi	r25, 0x20	; 32
 56c:	38 f0       	brcs	.+14     	; 0x57c <_ZN7TwoWire5writeEh+0x2c>
 56e:	81 e0       	ldi	r24, 0x01	; 1
 570:	90 e0       	ldi	r25, 0x00	; 0
 572:	93 83       	std	Z+3, r25	; 0x03
 574:	82 83       	std	Z+2, r24	; 0x02
 576:	80 e0       	ldi	r24, 0x00	; 0
 578:	90 e0       	ldi	r25, 0x00	; 0
 57a:	17 c0       	rjmp	.+46     	; 0x5aa <_ZN7TwoWire5writeEh+0x5a>
 57c:	80 91 cb 01 	lds	r24, 0x01CB	; 0x8001cb <_ZN7TwoWire13txBufferIndexE>
 580:	e8 2f       	mov	r30, r24
 582:	f0 e0       	ldi	r31, 0x00	; 0
 584:	e4 53       	subi	r30, 0x34	; 52
 586:	fe 4f       	sbci	r31, 0xFE	; 254
 588:	99 81       	ldd	r25, Y+1	; 0x01
 58a:	90 83       	st	Z, r25
 58c:	8f 5f       	subi	r24, 0xFF	; 255
 58e:	80 93 cb 01 	sts	0x01CB, r24	; 0x8001cb <_ZN7TwoWire13txBufferIndexE>
 592:	80 93 ca 01 	sts	0x01CA, r24	; 0x8001ca <_ZN7TwoWire14txBufferLengthE>
 596:	81 e0       	ldi	r24, 0x01	; 1
 598:	90 e0       	ldi	r25, 0x00	; 0
 59a:	07 c0       	rjmp	.+14     	; 0x5aa <_ZN7TwoWire5writeEh+0x5a>
 59c:	61 e0       	ldi	r22, 0x01	; 1
 59e:	ce 01       	movw	r24, r28
 5a0:	01 96       	adiw	r24, 0x01	; 1
 5a2:	0e 94 69 04 	call	0x8d2	; 0x8d2 <twi_transmit>
 5a6:	81 e0       	ldi	r24, 0x01	; 1
 5a8:	90 e0       	ldi	r25, 0x00	; 0
 5aa:	0f 90       	pop	r0
 5ac:	df 91       	pop	r29
 5ae:	cf 91       	pop	r28
 5b0:	08 95       	ret

000005b2 <_ZN7TwoWireC1Ev>:
 5b2:	fc 01       	movw	r30, r24
 5b4:	13 82       	std	Z+3, r1	; 0x03
 5b6:	12 82       	std	Z+2, r1	; 0x02
 5b8:	88 ee       	ldi	r24, 0xE8	; 232
 5ba:	93 e0       	ldi	r25, 0x03	; 3
 5bc:	a0 e0       	ldi	r26, 0x00	; 0
 5be:	b0 e0       	ldi	r27, 0x00	; 0
 5c0:	84 83       	std	Z+4, r24	; 0x04
 5c2:	95 83       	std	Z+5, r25	; 0x05
 5c4:	a6 83       	std	Z+6, r26	; 0x06
 5c6:	b7 83       	std	Z+7, r27	; 0x07
 5c8:	84 e1       	ldi	r24, 0x14	; 20
 5ca:	91 e0       	ldi	r25, 0x01	; 1
 5cc:	91 83       	std	Z+1, r25	; 0x01
 5ce:	80 83       	st	Z, r24
 5d0:	08 95       	ret

000005d2 <_GLOBAL__sub_I__ZN7TwoWire8rxBufferE>:
}

// Preinstantiate Objects //////////////////////////////////////////////////////

TwoWire Wire = TwoWire();
 5d2:	8d eb       	ldi	r24, 0xBD	; 189
 5d4:	91 e0       	ldi	r25, 0x01	; 1
 5d6:	0e 94 d9 02 	call	0x5b2	; 0x5b2 <_ZN7TwoWireC1Ev>
 5da:	08 95       	ret

000005dc <__vector_16>:
	

#endif

	// busy wait
	__asm__ __volatile__ (
 5dc:	1f 92       	push	r1
 5de:	0f 92       	push	r0
 5e0:	0f b6       	in	r0, 0x3f	; 63
 5e2:	0f 92       	push	r0
 5e4:	11 24       	eor	r1, r1
 5e6:	2f 93       	push	r18
 5e8:	3f 93       	push	r19
 5ea:	8f 93       	push	r24
 5ec:	9f 93       	push	r25
 5ee:	af 93       	push	r26
 5f0:	bf 93       	push	r27
 5f2:	80 91 0f 02 	lds	r24, 0x020F	; 0x80020f <timer0_millis>
 5f6:	90 91 10 02 	lds	r25, 0x0210	; 0x800210 <timer0_millis+0x1>
 5fa:	a0 91 11 02 	lds	r26, 0x0211	; 0x800211 <timer0_millis+0x2>
 5fe:	b0 91 12 02 	lds	r27, 0x0212	; 0x800212 <timer0_millis+0x3>
 602:	30 91 0e 02 	lds	r19, 0x020E	; 0x80020e <timer0_fract>
 606:	23 e0       	ldi	r18, 0x03	; 3
 608:	23 0f       	add	r18, r19
 60a:	2d 37       	cpi	r18, 0x7D	; 125
 60c:	20 f4       	brcc	.+8      	; 0x616 <__vector_16+0x3a>
 60e:	01 96       	adiw	r24, 0x01	; 1
 610:	a1 1d       	adc	r26, r1
 612:	b1 1d       	adc	r27, r1
 614:	05 c0       	rjmp	.+10     	; 0x620 <__vector_16+0x44>
 616:	26 e8       	ldi	r18, 0x86	; 134
 618:	23 0f       	add	r18, r19
 61a:	02 96       	adiw	r24, 0x02	; 2
 61c:	a1 1d       	adc	r26, r1
 61e:	b1 1d       	adc	r27, r1
 620:	20 93 0e 02 	sts	0x020E, r18	; 0x80020e <timer0_fract>
 624:	80 93 0f 02 	sts	0x020F, r24	; 0x80020f <timer0_millis>
 628:	90 93 10 02 	sts	0x0210, r25	; 0x800210 <timer0_millis+0x1>
 62c:	a0 93 11 02 	sts	0x0211, r26	; 0x800211 <timer0_millis+0x2>
 630:	b0 93 12 02 	sts	0x0212, r27	; 0x800212 <timer0_millis+0x3>
 634:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <timer0_overflow_count>
 638:	90 91 14 02 	lds	r25, 0x0214	; 0x800214 <timer0_overflow_count+0x1>
 63c:	a0 91 15 02 	lds	r26, 0x0215	; 0x800215 <timer0_overflow_count+0x2>
 640:	b0 91 16 02 	lds	r27, 0x0216	; 0x800216 <timer0_overflow_count+0x3>
 644:	01 96       	adiw	r24, 0x01	; 1
 646:	a1 1d       	adc	r26, r1
 648:	b1 1d       	adc	r27, r1
 64a:	80 93 13 02 	sts	0x0213, r24	; 0x800213 <timer0_overflow_count>
 64e:	90 93 14 02 	sts	0x0214, r25	; 0x800214 <timer0_overflow_count+0x1>
 652:	a0 93 15 02 	sts	0x0215, r26	; 0x800215 <timer0_overflow_count+0x2>
 656:	b0 93 16 02 	sts	0x0216, r27	; 0x800216 <timer0_overflow_count+0x3>
 65a:	bf 91       	pop	r27
 65c:	af 91       	pop	r26
 65e:	9f 91       	pop	r25
 660:	8f 91       	pop	r24
 662:	3f 91       	pop	r19
 664:	2f 91       	pop	r18
 666:	0f 90       	pop	r0
 668:	0f be       	out	0x3f, r0	; 63
 66a:	0f 90       	pop	r0
 66c:	1f 90       	pop	r1
 66e:	18 95       	reti

00000670 <micros>:
 670:	3f b7       	in	r19, 0x3f	; 63
 672:	f8 94       	cli
 674:	80 91 13 02 	lds	r24, 0x0213	; 0x800213 <timer0_overflow_count>
 678:	90 91 14 02 	lds	r25, 0x0214	; 0x800214 <timer0_overflow_count+0x1>
 67c:	a0 91 15 02 	lds	r26, 0x0215	; 0x800215 <timer0_overflow_count+0x2>
 680:	b0 91 16 02 	lds	r27, 0x0216	; 0x800216 <timer0_overflow_count+0x3>
 684:	26 b5       	in	r18, 0x26	; 38
 686:	a8 9b       	sbis	0x15, 0	; 21
 688:	05 c0       	rjmp	.+10     	; 0x694 <micros+0x24>
 68a:	2f 3f       	cpi	r18, 0xFF	; 255
 68c:	19 f0       	breq	.+6      	; 0x694 <micros+0x24>
 68e:	01 96       	adiw	r24, 0x01	; 1
 690:	a1 1d       	adc	r26, r1
 692:	b1 1d       	adc	r27, r1
 694:	3f bf       	out	0x3f, r19	; 63
 696:	ba 2f       	mov	r27, r26
 698:	a9 2f       	mov	r26, r25
 69a:	98 2f       	mov	r25, r24
 69c:	88 27       	eor	r24, r24
 69e:	82 0f       	add	r24, r18
 6a0:	91 1d       	adc	r25, r1
 6a2:	a1 1d       	adc	r26, r1
 6a4:	b1 1d       	adc	r27, r1
 6a6:	bc 01       	movw	r22, r24
 6a8:	cd 01       	movw	r24, r26
 6aa:	42 e0       	ldi	r20, 0x02	; 2
 6ac:	66 0f       	add	r22, r22
 6ae:	77 1f       	adc	r23, r23
 6b0:	88 1f       	adc	r24, r24
 6b2:	99 1f       	adc	r25, r25
 6b4:	4a 95       	dec	r20
 6b6:	d1 f7       	brne	.-12     	; 0x6ac <micros+0x3c>
 6b8:	08 95       	ret

000006ba <delay>:
 6ba:	8f 92       	push	r8
 6bc:	9f 92       	push	r9
 6be:	af 92       	push	r10
 6c0:	bf 92       	push	r11
 6c2:	cf 92       	push	r12
 6c4:	df 92       	push	r13
 6c6:	ef 92       	push	r14
 6c8:	ff 92       	push	r15
 6ca:	6b 01       	movw	r12, r22
 6cc:	7c 01       	movw	r14, r24
 6ce:	0e 94 38 03 	call	0x670	; 0x670 <micros>
 6d2:	4b 01       	movw	r8, r22
 6d4:	5c 01       	movw	r10, r24
 6d6:	c1 14       	cp	r12, r1
 6d8:	d1 04       	cpc	r13, r1
 6da:	e1 04       	cpc	r14, r1
 6dc:	f1 04       	cpc	r15, r1
 6de:	01 f1       	breq	.+64     	; 0x720 <delay+0x66>
 6e0:	0e 94 68 04 	call	0x8d0	; 0x8d0 <yield>
 6e4:	0e 94 38 03 	call	0x670	; 0x670 <micros>
 6e8:	dc 01       	movw	r26, r24
 6ea:	cb 01       	movw	r24, r22
 6ec:	88 19       	sub	r24, r8
 6ee:	99 09       	sbc	r25, r9
 6f0:	aa 09       	sbc	r26, r10
 6f2:	bb 09       	sbc	r27, r11
 6f4:	88 3e       	cpi	r24, 0xE8	; 232
 6f6:	93 40       	sbci	r25, 0x03	; 3
 6f8:	a1 05       	cpc	r26, r1
 6fa:	b1 05       	cpc	r27, r1
 6fc:	60 f3       	brcs	.-40     	; 0x6d6 <delay+0x1c>
 6fe:	21 e0       	ldi	r18, 0x01	; 1
 700:	c2 1a       	sub	r12, r18
 702:	d1 08       	sbc	r13, r1
 704:	e1 08       	sbc	r14, r1
 706:	f1 08       	sbc	r15, r1
 708:	88 ee       	ldi	r24, 0xE8	; 232
 70a:	88 0e       	add	r8, r24
 70c:	83 e0       	ldi	r24, 0x03	; 3
 70e:	98 1e       	adc	r9, r24
 710:	a1 1c       	adc	r10, r1
 712:	b1 1c       	adc	r11, r1
 714:	c1 14       	cp	r12, r1
 716:	d1 04       	cpc	r13, r1
 718:	e1 04       	cpc	r14, r1
 71a:	f1 04       	cpc	r15, r1
 71c:	19 f7       	brne	.-58     	; 0x6e4 <delay+0x2a>
 71e:	db cf       	rjmp	.-74     	; 0x6d6 <delay+0x1c>
 720:	ff 90       	pop	r15
 722:	ef 90       	pop	r14
 724:	df 90       	pop	r13
 726:	cf 90       	pop	r12
 728:	bf 90       	pop	r11
 72a:	af 90       	pop	r10
 72c:	9f 90       	pop	r9
 72e:	8f 90       	pop	r8
 730:	08 95       	ret

00000732 <init>:

void init()
{
	// this needs to be called before setup() or some functions won't
	// work there
	sei();
 732:	78 94       	sei
	
	// on the ATmega168, timer 0 is also used for fast hardware pwm
	// (using phase-correct PWM would mean that timer 0 overflowed half as often
	// resulting in different millis() behavior on the ATmega8 and ATmega168)
#if defined(TCCR0A) && defined(WGM01)
	sbi(TCCR0A, WGM01);
 734:	84 b5       	in	r24, 0x24	; 36
 736:	82 60       	ori	r24, 0x02	; 2
 738:	84 bd       	out	0x24, r24	; 36
	sbi(TCCR0A, WGM00);
 73a:	84 b5       	in	r24, 0x24	; 36
 73c:	81 60       	ori	r24, 0x01	; 1
 73e:	84 bd       	out	0x24, r24	; 36
	// this combination is for the standard atmega8
	sbi(TCCR0, CS01);
	sbi(TCCR0, CS00);
#elif defined(TCCR0B) && defined(CS01) && defined(CS00)
	// this combination is for the standard 168/328/1280/2560
	sbi(TCCR0B, CS01);
 740:	85 b5       	in	r24, 0x25	; 37
 742:	82 60       	ori	r24, 0x02	; 2
 744:	85 bd       	out	0x25, r24	; 37
	sbi(TCCR0B, CS00);
 746:	85 b5       	in	r24, 0x25	; 37
 748:	81 60       	ori	r24, 0x01	; 1
 74a:	85 bd       	out	0x25, r24	; 37

	// enable timer 0 overflow interrupt
#if defined(TIMSK) && defined(TOIE0)
	sbi(TIMSK, TOIE0);
#elif defined(TIMSK0) && defined(TOIE0)
	sbi(TIMSK0, TOIE0);
 74c:	ee e6       	ldi	r30, 0x6E	; 110
 74e:	f0 e0       	ldi	r31, 0x00	; 0
 750:	80 81       	ld	r24, Z
 752:	81 60       	ori	r24, 0x01	; 1
 754:	80 83       	st	Z, r24
	// this is better for motors as it ensures an even waveform
	// note, however, that fast pwm mode can achieve a frequency of up
	// 8 MHz (with a 16 MHz clock) at 50% duty cycle

#if defined(TCCR1B) && defined(CS11) && defined(CS10)
	TCCR1B = 0;
 756:	e1 e8       	ldi	r30, 0x81	; 129
 758:	f0 e0       	ldi	r31, 0x00	; 0
 75a:	10 82       	st	Z, r1

	// set timer 1 prescale factor to 64
	sbi(TCCR1B, CS11);
 75c:	80 81       	ld	r24, Z
 75e:	82 60       	ori	r24, 0x02	; 2
 760:	80 83       	st	Z, r24
#if F_CPU >= 8000000L
	sbi(TCCR1B, CS10);
 762:	80 81       	ld	r24, Z
 764:	81 60       	ori	r24, 0x01	; 1
 766:	80 83       	st	Z, r24
	sbi(TCCR1, CS10);
#endif
#endif
	// put timer 1 in 8-bit phase correct pwm mode
#if defined(TCCR1A) && defined(WGM10)
	sbi(TCCR1A, WGM10);
 768:	e0 e8       	ldi	r30, 0x80	; 128
 76a:	f0 e0       	ldi	r31, 0x00	; 0
 76c:	80 81       	ld	r24, Z
 76e:	81 60       	ori	r24, 0x01	; 1
 770:	80 83       	st	Z, r24

	// set timer 2 prescale factor to 64
#if defined(TCCR2) && defined(CS22)
	sbi(TCCR2, CS22);
#elif defined(TCCR2B) && defined(CS22)
	sbi(TCCR2B, CS22);
 772:	e1 eb       	ldi	r30, 0xB1	; 177
 774:	f0 e0       	ldi	r31, 0x00	; 0
 776:	80 81       	ld	r24, Z
 778:	84 60       	ori	r24, 0x04	; 4
 77a:	80 83       	st	Z, r24

	// configure timer 2 for phase correct pwm (8-bit)
#if defined(TCCR2) && defined(WGM20)
	sbi(TCCR2, WGM20);
#elif defined(TCCR2A) && defined(WGM20)
	sbi(TCCR2A, WGM20);
 77c:	e0 eb       	ldi	r30, 0xB0	; 176
 77e:	f0 e0       	ldi	r31, 0x00	; 0
 780:	80 81       	ld	r24, Z
 782:	81 60       	ori	r24, 0x01	; 1
 784:	80 83       	st	Z, r24
#endif

#if defined(ADCSRA)
	// set a2d prescaler so we are inside the desired 50-200 KHz range.
	#if F_CPU >= 16000000 // 16 MHz / 128 = 125 KHz
		sbi(ADCSRA, ADPS2);
 786:	ea e7       	ldi	r30, 0x7A	; 122
 788:	f0 e0       	ldi	r31, 0x00	; 0
 78a:	80 81       	ld	r24, Z
 78c:	84 60       	ori	r24, 0x04	; 4
 78e:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS1);
 790:	80 81       	ld	r24, Z
 792:	82 60       	ori	r24, 0x02	; 2
 794:	80 83       	st	Z, r24
		sbi(ADCSRA, ADPS0);
 796:	80 81       	ld	r24, Z
 798:	81 60       	ori	r24, 0x01	; 1
 79a:	80 83       	st	Z, r24
		cbi(ADCSRA, ADPS2);
		cbi(ADCSRA, ADPS1);
		sbi(ADCSRA, ADPS0);
	#endif
	// enable a2d conversions
	sbi(ADCSRA, ADEN);
 79c:	80 81       	ld	r24, Z
 79e:	80 68       	ori	r24, 0x80	; 128
 7a0:	80 83       	st	Z, r24
	// here so they can be used as normal digital i/o; they will be
	// reconnected in Serial.begin()
#if defined(UCSRB)
	UCSRB = 0;
#elif defined(UCSR0B)
	UCSR0B = 0;
 7a2:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7e00c1>
 7a6:	08 95       	ret

000007a8 <turnOffPWM>:
//
//static inline void turnOffPWM(uint8_t timer) __attribute__ ((always_inline));
//static inline void turnOffPWM(uint8_t timer)
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
 7a8:	83 30       	cpi	r24, 0x03	; 3
 7aa:	81 f0       	breq	.+32     	; 0x7cc <turnOffPWM+0x24>
 7ac:	28 f4       	brcc	.+10     	; 0x7b8 <turnOffPWM+0x10>
 7ae:	81 30       	cpi	r24, 0x01	; 1
 7b0:	99 f0       	breq	.+38     	; 0x7d8 <turnOffPWM+0x30>
 7b2:	82 30       	cpi	r24, 0x02	; 2
 7b4:	a1 f0       	breq	.+40     	; 0x7de <turnOffPWM+0x36>
 7b6:	08 95       	ret
 7b8:	87 30       	cpi	r24, 0x07	; 7
 7ba:	a9 f0       	breq	.+42     	; 0x7e6 <turnOffPWM+0x3e>
 7bc:	88 30       	cpi	r24, 0x08	; 8
 7be:	b9 f0       	breq	.+46     	; 0x7ee <turnOffPWM+0x46>
 7c0:	84 30       	cpi	r24, 0x04	; 4
 7c2:	d1 f4       	brne	.+52     	; 0x7f8 <turnOffPWM+0x50>
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 7c4:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 7c8:	8f 7d       	andi	r24, 0xDF	; 223
 7ca:	03 c0       	rjmp	.+6      	; 0x7d2 <turnOffPWM+0x2a>
static void turnOffPWM(uint8_t timer)
{
	switch (timer)
	{
		#if defined(TCCR1A) && defined(COM1A1)
		case TIMER1A:   cbi(TCCR1A, COM1A1);    break;
 7cc:	80 91 80 00 	lds	r24, 0x0080	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 7d0:	8f 77       	andi	r24, 0x7F	; 127
		#endif
		#if defined(TCCR1A) && defined(COM1B1)
		case TIMER1B:   cbi(TCCR1A, COM1B1);    break;
 7d2:	80 93 80 00 	sts	0x0080, r24	; 0x800080 <__TEXT_REGION_LENGTH__+0x7e0080>
 7d6:	08 95       	ret
		#if defined(TCCR2) && defined(COM21)
		case  TIMER2:   cbi(TCCR2, COM21);      break;
		#endif
		
		#if defined(TCCR0A) && defined(COM0A1)
		case  TIMER0A:  cbi(TCCR0A, COM0A1);    break;
 7d8:	84 b5       	in	r24, 0x24	; 36
 7da:	8f 77       	andi	r24, 0x7F	; 127
 7dc:	02 c0       	rjmp	.+4      	; 0x7e2 <turnOffPWM+0x3a>
		#endif
		
		#if defined(TCCR0A) && defined(COM0B1)
		case  TIMER0B:  cbi(TCCR0A, COM0B1);    break;
 7de:	84 b5       	in	r24, 0x24	; 36
 7e0:	8f 7d       	andi	r24, 0xDF	; 223
 7e2:	84 bd       	out	0x24, r24	; 36
 7e4:	08 95       	ret
		#endif
		#if defined(TCCR2A) && defined(COM2A1)
		case  TIMER2A:  cbi(TCCR2A, COM2A1);    break;
 7e6:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 7ea:	8f 77       	andi	r24, 0x7F	; 127
 7ec:	03 c0       	rjmp	.+6      	; 0x7f4 <turnOffPWM+0x4c>
		#endif
		#if defined(TCCR2A) && defined(COM2B1)
		case  TIMER2B:  cbi(TCCR2A, COM2B1);    break;
 7ee:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 7f2:	8f 7d       	andi	r24, 0xDF	; 223
 7f4:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
 7f8:	08 95       	ret

000007fa <pinMode>:
#define ARDUINO_MAIN
#include "wiring_private.h"
#include "pins_arduino.h"

void pinMode(uint8_t pin, uint8_t mode)
{
 7fa:	cf 93       	push	r28
 7fc:	df 93       	push	r29
	uint8_t bit = digitalPinToBitMask(pin);
 7fe:	90 e0       	ldi	r25, 0x00	; 0
 800:	fc 01       	movw	r30, r24
 802:	e4 58       	subi	r30, 0x84	; 132
 804:	ff 4f       	sbci	r31, 0xFF	; 255
 806:	24 91       	lpm	r18, Z
	uint8_t port = digitalPinToPort(pin);
 808:	fc 01       	movw	r30, r24
 80a:	e0 57       	subi	r30, 0x70	; 112
 80c:	ff 4f       	sbci	r31, 0xFF	; 255
 80e:	84 91       	lpm	r24, Z
	volatile uint8_t *reg, *out;

	if (port == NOT_A_PIN) return;
 810:	88 23       	and	r24, r24
 812:	61 f1       	breq	.+88     	; 0x86c <pinMode+0x72>

	// JWS: can I let the optimizer do this?
	reg = portModeRegister(port);
 814:	90 e0       	ldi	r25, 0x00	; 0
 816:	88 0f       	add	r24, r24
 818:	99 1f       	adc	r25, r25
 81a:	fc 01       	movw	r30, r24
 81c:	e2 55       	subi	r30, 0x52	; 82
 81e:	ff 4f       	sbci	r31, 0xFF	; 255
 820:	c5 91       	lpm	r28, Z+
 822:	d4 91       	lpm	r29, Z
	out = portOutputRegister(port);
 824:	fc 01       	movw	r30, r24
 826:	ec 55       	subi	r30, 0x5C	; 92
 828:	ff 4f       	sbci	r31, 0xFF	; 255
 82a:	a5 91       	lpm	r26, Z+
 82c:	b4 91       	lpm	r27, Z

	if (mode == INPUT) { 
 82e:	61 11       	cpse	r22, r1
 830:	09 c0       	rjmp	.+18     	; 0x844 <pinMode+0x4a>
		uint8_t oldSREG = SREG;
 832:	9f b7       	in	r25, 0x3f	; 63
                cli();
 834:	f8 94       	cli
		*reg &= ~bit;
 836:	88 81       	ld	r24, Y
 838:	20 95       	com	r18
 83a:	82 23       	and	r24, r18
 83c:	88 83       	st	Y, r24
		*out &= ~bit;
 83e:	ec 91       	ld	r30, X
 840:	2e 23       	and	r18, r30
 842:	0b c0       	rjmp	.+22     	; 0x85a <pinMode+0x60>
		SREG = oldSREG;
	} else if (mode == INPUT_PULLUP) {
 844:	62 30       	cpi	r22, 0x02	; 2
 846:	61 f4       	brne	.+24     	; 0x860 <pinMode+0x66>
		uint8_t oldSREG = SREG;
 848:	9f b7       	in	r25, 0x3f	; 63
                cli();
 84a:	f8 94       	cli
		*reg &= ~bit;
 84c:	88 81       	ld	r24, Y
 84e:	32 2f       	mov	r19, r18
 850:	30 95       	com	r19
 852:	83 23       	and	r24, r19
 854:	88 83       	st	Y, r24
		*out |= bit;
 856:	ec 91       	ld	r30, X
 858:	2e 2b       	or	r18, r30
 85a:	2c 93       	st	X, r18
		SREG = oldSREG;
 85c:	9f bf       	out	0x3f, r25	; 63
 85e:	06 c0       	rjmp	.+12     	; 0x86c <pinMode+0x72>
	} else {
		uint8_t oldSREG = SREG;
 860:	8f b7       	in	r24, 0x3f	; 63
                cli();
 862:	f8 94       	cli
		*reg |= bit;
 864:	e8 81       	ld	r30, Y
 866:	2e 2b       	or	r18, r30
 868:	28 83       	st	Y, r18
		SREG = oldSREG;
 86a:	8f bf       	out	0x3f, r24	; 63
	}
}
 86c:	df 91       	pop	r29
 86e:	cf 91       	pop	r28
 870:	08 95       	ret

00000872 <digitalWrite>:
		#endif
	}
}

void digitalWrite(uint8_t pin, uint8_t val)
{
 872:	1f 93       	push	r17
 874:	cf 93       	push	r28
 876:	df 93       	push	r29
	uint8_t timer = digitalPinToTimer(pin);
 878:	28 2f       	mov	r18, r24
 87a:	30 e0       	ldi	r19, 0x00	; 0
 87c:	f9 01       	movw	r30, r18
 87e:	e8 59       	subi	r30, 0x98	; 152
 880:	ff 4f       	sbci	r31, 0xFF	; 255
 882:	84 91       	lpm	r24, Z
	uint8_t bit = digitalPinToBitMask(pin);
 884:	f9 01       	movw	r30, r18
 886:	e4 58       	subi	r30, 0x84	; 132
 888:	ff 4f       	sbci	r31, 0xFF	; 255
 88a:	d4 91       	lpm	r29, Z
	uint8_t port = digitalPinToPort(pin);
 88c:	f9 01       	movw	r30, r18
 88e:	e0 57       	subi	r30, 0x70	; 112
 890:	ff 4f       	sbci	r31, 0xFF	; 255
 892:	c4 91       	lpm	r28, Z
	volatile uint8_t *out;

	if (port == NOT_A_PIN) return;
 894:	cc 23       	and	r28, r28
 896:	c1 f0       	breq	.+48     	; 0x8c8 <digitalWrite+0x56>
 898:	16 2f       	mov	r17, r22

	// If the pin that support PWM output, we need to turn it off
	// before doing a digital write.
	if (timer != NOT_ON_TIMER) turnOffPWM(timer);
 89a:	81 11       	cpse	r24, r1
 89c:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <turnOffPWM>

	out = portOutputRegister(port);
 8a0:	ec 2f       	mov	r30, r28
 8a2:	f0 e0       	ldi	r31, 0x00	; 0
 8a4:	ee 0f       	add	r30, r30
 8a6:	ff 1f       	adc	r31, r31
 8a8:	ec 55       	subi	r30, 0x5C	; 92
 8aa:	ff 4f       	sbci	r31, 0xFF	; 255
 8ac:	a5 91       	lpm	r26, Z+
 8ae:	b4 91       	lpm	r27, Z

	uint8_t oldSREG = SREG;
 8b0:	9f b7       	in	r25, 0x3f	; 63
	cli();
 8b2:	f8 94       	cli

	if (val == LOW) {
 8b4:	11 11       	cpse	r17, r1
 8b6:	04 c0       	rjmp	.+8      	; 0x8c0 <digitalWrite+0x4e>
		*out &= ~bit;
 8b8:	8c 91       	ld	r24, X
 8ba:	d0 95       	com	r29
 8bc:	d8 23       	and	r29, r24
 8be:	02 c0       	rjmp	.+4      	; 0x8c4 <digitalWrite+0x52>
	} else {
		*out |= bit;
 8c0:	ec 91       	ld	r30, X
 8c2:	de 2b       	or	r29, r30
 8c4:	dc 93       	st	X, r29
	}

	SREG = oldSREG;
 8c6:	9f bf       	out	0x3f, r25	; 63
}
 8c8:	df 91       	pop	r29
 8ca:	cf 91       	pop	r28
 8cc:	1f 91       	pop	r17
 8ce:	08 95       	ret

000008d0 <yield>:
 * libraries or sketches that supports cooperative threads.
 *
 * Its defined as a weak symbol and it can be redefined to implement a
 * real cooperative scheduler.
 */
static void __empty() {
 8d0:	08 95       	ret

000008d2 <twi_transmit>:
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
 8d2:	40 91 39 02 	lds	r20, 0x0239	; 0x800239 <twi_txBufferLength>
 8d6:	26 2f       	mov	r18, r22
 8d8:	30 e0       	ldi	r19, 0x00	; 0
 8da:	24 0f       	add	r18, r20
 8dc:	31 1d       	adc	r19, r1
 8de:	21 32       	cpi	r18, 0x21	; 33
 8e0:	31 05       	cpc	r19, r1
 8e2:	dc f4       	brge	.+54     	; 0x91a <__stack+0x1b>
 8e4:	20 91 84 02 	lds	r18, 0x0284	; 0x800284 <twi_state>
 8e8:	24 30       	cpi	r18, 0x04	; 4
 8ea:	c9 f4       	brne	.+50     	; 0x91e <__stack+0x1f>
 8ec:	fc 01       	movw	r30, r24
 8ee:	80 e0       	ldi	r24, 0x00	; 0
 8f0:	90 e0       	ldi	r25, 0x00	; 0
 8f2:	86 17       	cp	r24, r22
 8f4:	58 f4       	brcc	.+22     	; 0x90c <__stack+0xd>
 8f6:	30 91 39 02 	lds	r19, 0x0239	; 0x800239 <twi_txBufferLength>
 8fa:	21 91       	ld	r18, Z+
 8fc:	dc 01       	movw	r26, r24
 8fe:	a5 5c       	subi	r26, 0xC5	; 197
 900:	bd 4f       	sbci	r27, 0xFD	; 253
 902:	a3 0f       	add	r26, r19
 904:	b1 1d       	adc	r27, r1
 906:	2c 93       	st	X, r18
 908:	01 96       	adiw	r24, 0x01	; 1
 90a:	f3 cf       	rjmp	.-26     	; 0x8f2 <twi_transmit+0x20>
 90c:	80 91 39 02 	lds	r24, 0x0239	; 0x800239 <twi_txBufferLength>
 910:	68 0f       	add	r22, r24
 912:	60 93 39 02 	sts	0x0239, r22	; 0x800239 <twi_txBufferLength>
 916:	80 e0       	ldi	r24, 0x00	; 0
 918:	08 95       	ret
 91a:	81 e0       	ldi	r24, 0x01	; 1
 91c:	08 95       	ret
 91e:	82 e0       	ldi	r24, 0x02	; 2
 920:	08 95       	ret

00000922 <twi_stop>:
 * Output   none
 */
void twi_stop(void)
{
  // send stop condition
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT) | _BV(TWSTO);
 922:	85 ed       	ldi	r24, 0xD5	; 213
 924:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>

  // wait for stop condition to be exectued on bus
  // TWINT is not set after a stop condition!
  while(TWCR & _BV(TWSTO)){
 928:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 92c:	84 fd       	sbrc	r24, 4
 92e:	fc cf       	rjmp	.-8      	; 0x928 <twi_stop+0x6>
    continue;
  }

  // update twi state
  twi_state = TWI_READY;
 930:	10 92 84 02 	sts	0x0284, r1	; 0x800284 <twi_state>
 934:	08 95       	ret

00000936 <twi_releaseBus>:
 * Output   none
 */
void twi_releaseBus(void)
{
  // release bus
  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWEA) | _BV(TWINT);
 936:	85 ec       	ldi	r24, 0xC5	; 197
 938:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>

  // update twi state
  twi_state = TWI_READY;
 93c:	10 92 84 02 	sts	0x0284, r1	; 0x800284 <twi_state>
 940:	08 95       	ret

00000942 <__vector_24>:
}

ISR(TWI_vect)
{
 942:	1f 92       	push	r1
 944:	0f 92       	push	r0
 946:	0f b6       	in	r0, 0x3f	; 63
 948:	0f 92       	push	r0
 94a:	11 24       	eor	r1, r1
 94c:	2f 93       	push	r18
 94e:	3f 93       	push	r19
 950:	4f 93       	push	r20
 952:	5f 93       	push	r21
 954:	6f 93       	push	r22
 956:	7f 93       	push	r23
 958:	8f 93       	push	r24
 95a:	9f 93       	push	r25
 95c:	af 93       	push	r26
 95e:	bf 93       	push	r27
 960:	ef 93       	push	r30
 962:	ff 93       	push	r31
  switch(TW_STATUS){
 964:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7e00b9>
 968:	88 7f       	andi	r24, 0xF8	; 248
 96a:	80 36       	cpi	r24, 0x60	; 96
 96c:	09 f4       	brne	.+2      	; 0x970 <__vector_24+0x2e>
 96e:	9e c0       	rjmp	.+316    	; 0xaac <__vector_24+0x16a>
 970:	78 f5       	brcc	.+94     	; 0x9d0 <__vector_24+0x8e>
 972:	88 32       	cpi	r24, 0x28	; 40
 974:	09 f4       	brne	.+2      	; 0x978 <__vector_24+0x36>
 976:	5d c0       	rjmp	.+186    	; 0xa32 <__vector_24+0xf0>
 978:	90 f4       	brcc	.+36     	; 0x99e <__vector_24+0x5c>
 97a:	80 31       	cpi	r24, 0x10	; 16
 97c:	09 f4       	brne	.+2      	; 0x980 <__vector_24+0x3e>
 97e:	56 c0       	rjmp	.+172    	; 0xa2c <__vector_24+0xea>
 980:	38 f4       	brcc	.+14     	; 0x990 <__vector_24+0x4e>
 982:	88 23       	and	r24, r24
 984:	09 f4       	brne	.+2      	; 0x988 <__vector_24+0x46>
 986:	f5 c0       	rjmp	.+490    	; 0xb72 <__vector_24+0x230>
 988:	88 30       	cpi	r24, 0x08	; 8
 98a:	09 f4       	brne	.+2      	; 0x98e <__vector_24+0x4c>
 98c:	4f c0       	rjmp	.+158    	; 0xa2c <__vector_24+0xea>
 98e:	f5 c0       	rjmp	.+490    	; 0xb7a <__vector_24+0x238>
 990:	88 31       	cpi	r24, 0x18	; 24
 992:	09 f4       	brne	.+2      	; 0x996 <__vector_24+0x54>
 994:	4e c0       	rjmp	.+156    	; 0xa32 <__vector_24+0xf0>
 996:	80 32       	cpi	r24, 0x20	; 32
 998:	09 f4       	brne	.+2      	; 0x99c <__vector_24+0x5a>
 99a:	5f c0       	rjmp	.+190    	; 0xa5a <__vector_24+0x118>
 99c:	ee c0       	rjmp	.+476    	; 0xb7a <__vector_24+0x238>
 99e:	80 34       	cpi	r24, 0x40	; 64
 9a0:	09 f4       	brne	.+2      	; 0x9a4 <__vector_24+0x62>
 9a2:	6a c0       	rjmp	.+212    	; 0xa78 <__vector_24+0x136>
 9a4:	58 f4       	brcc	.+22     	; 0x9bc <__vector_24+0x7a>
 9a6:	80 33       	cpi	r24, 0x30	; 48
 9a8:	09 f4       	brne	.+2      	; 0x9ac <__vector_24+0x6a>
 9aa:	57 c0       	rjmp	.+174    	; 0xa5a <__vector_24+0x118>
 9ac:	88 33       	cpi	r24, 0x38	; 56
 9ae:	09 f0       	breq	.+2      	; 0x9b2 <__vector_24+0x70>
 9b0:	e4 c0       	rjmp	.+456    	; 0xb7a <__vector_24+0x238>
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
      twi_stop();
      break;
    case TW_MT_ARB_LOST: // lost bus arbitration
      twi_error = TW_MT_ARB_LOST;
 9b2:	80 93 17 02 	sts	0x0217, r24	; 0x800217 <twi_error>
      twi_releaseBus();
 9b6:	0e 94 9b 04 	call	0x936	; 0x936 <twi_releaseBus>
      break;
 9ba:	df c0       	rjmp	.+446    	; 0xb7a <__vector_24+0x238>
  twi_state = TWI_READY;
}

ISR(TWI_vect)
{
  switch(TW_STATUS){
 9bc:	80 35       	cpi	r24, 0x50	; 80
 9be:	09 f4       	brne	.+2      	; 0x9c2 <__vector_24+0x80>
 9c0:	4f c0       	rjmp	.+158    	; 0xa60 <__vector_24+0x11e>
 9c2:	88 35       	cpi	r24, 0x58	; 88
 9c4:	09 f4       	brne	.+2      	; 0x9c8 <__vector_24+0x86>
 9c6:	5d c0       	rjmp	.+186    	; 0xa82 <__vector_24+0x140>
 9c8:	88 34       	cpi	r24, 0x48	; 72
 9ca:	09 f0       	breq	.+2      	; 0x9ce <__vector_24+0x8c>
 9cc:	d6 c0       	rjmp	.+428    	; 0xb7a <__vector_24+0x238>
 9ce:	d3 c0       	rjmp	.+422    	; 0xb76 <__vector_24+0x234>
 9d0:	88 39       	cpi	r24, 0x98	; 152
 9d2:	09 f4       	brne	.+2      	; 0x9d6 <__vector_24+0x94>
 9d4:	c4 c0       	rjmp	.+392    	; 0xb5e <__vector_24+0x21c>
 9d6:	a8 f4       	brcc	.+42     	; 0xa02 <__vector_24+0xc0>
 9d8:	88 37       	cpi	r24, 0x78	; 120
 9da:	09 f4       	brne	.+2      	; 0x9de <__vector_24+0x9c>
 9dc:	67 c0       	rjmp	.+206    	; 0xaac <__vector_24+0x16a>
 9de:	38 f4       	brcc	.+14     	; 0x9ee <__vector_24+0xac>
 9e0:	88 36       	cpi	r24, 0x68	; 104
 9e2:	09 f4       	brne	.+2      	; 0x9e6 <__vector_24+0xa4>
 9e4:	63 c0       	rjmp	.+198    	; 0xaac <__vector_24+0x16a>
 9e6:	80 37       	cpi	r24, 0x70	; 112
 9e8:	09 f4       	brne	.+2      	; 0x9ec <__vector_24+0xaa>
 9ea:	60 c0       	rjmp	.+192    	; 0xaac <__vector_24+0x16a>
 9ec:	c6 c0       	rjmp	.+396    	; 0xb7a <__vector_24+0x238>
 9ee:	88 38       	cpi	r24, 0x88	; 136
 9f0:	09 f4       	brne	.+2      	; 0x9f4 <__vector_24+0xb2>
 9f2:	b5 c0       	rjmp	.+362    	; 0xb5e <__vector_24+0x21c>
 9f4:	80 39       	cpi	r24, 0x90	; 144
 9f6:	09 f4       	brne	.+2      	; 0x9fa <__vector_24+0xb8>
 9f8:	5f c0       	rjmp	.+190    	; 0xab8 <__vector_24+0x176>
 9fa:	80 38       	cpi	r24, 0x80	; 128
 9fc:	09 f0       	breq	.+2      	; 0xa00 <__vector_24+0xbe>
 9fe:	bd c0       	rjmp	.+378    	; 0xb7a <__vector_24+0x238>
 a00:	5b c0       	rjmp	.+182    	; 0xab8 <__vector_24+0x176>
 a02:	80 3b       	cpi	r24, 0xB0	; 176
 a04:	09 f4       	brne	.+2      	; 0xa08 <__vector_24+0xc6>
 a06:	83 c0       	rjmp	.+262    	; 0xb0e <__vector_24+0x1cc>
 a08:	38 f4       	brcc	.+14     	; 0xa18 <__vector_24+0xd6>
 a0a:	80 3a       	cpi	r24, 0xA0	; 160
 a0c:	09 f4       	brne	.+2      	; 0xa10 <__vector_24+0xce>
 a0e:	66 c0       	rjmp	.+204    	; 0xadc <__vector_24+0x19a>
 a10:	88 3a       	cpi	r24, 0xA8	; 168
 a12:	09 f4       	brne	.+2      	; 0xa16 <__vector_24+0xd4>
 a14:	7c c0       	rjmp	.+248    	; 0xb0e <__vector_24+0x1cc>
 a16:	b1 c0       	rjmp	.+354    	; 0xb7a <__vector_24+0x238>
 a18:	80 3c       	cpi	r24, 0xC0	; 192
 a1a:	09 f4       	brne	.+2      	; 0xa1e <__vector_24+0xdc>
 a1c:	a4 c0       	rjmp	.+328    	; 0xb66 <__vector_24+0x224>
 a1e:	88 3c       	cpi	r24, 0xC8	; 200
 a20:	09 f4       	brne	.+2      	; 0xa24 <__vector_24+0xe2>
 a22:	a1 c0       	rjmp	.+322    	; 0xb66 <__vector_24+0x224>
 a24:	88 3b       	cpi	r24, 0xB8	; 184
 a26:	09 f4       	brne	.+2      	; 0xa2a <__vector_24+0xe8>
 a28:	87 c0       	rjmp	.+270    	; 0xb38 <__vector_24+0x1f6>
 a2a:	a7 c0       	rjmp	.+334    	; 0xb7a <__vector_24+0x238>
    // All Master
    case TW_START:     // sent start condition
    case TW_REP_START: // sent repeated start condition
      // copy device address and r/w bit to output register and ack
      TWDR = twi_slarw;
 a2c:	80 91 83 02 	lds	r24, 0x0283	; 0x800283 <twi_slarw>
 a30:	10 c0       	rjmp	.+32     	; 0xa52 <__vector_24+0x110>

    // Master Transmitter
    case TW_MT_SLA_ACK:  // slave receiver acked address
    case TW_MT_DATA_ACK: // slave receiver acked data
      // if there is data to send, send it, otherwise stop 
      if(twi_masterBufferIndex < twi_masterBufferLength){
 a32:	90 91 5c 02 	lds	r25, 0x025C	; 0x80025c <twi_masterBufferIndex>
 a36:	80 91 5b 02 	lds	r24, 0x025B	; 0x80025b <twi_masterBufferLength>
 a3a:	98 17       	cp	r25, r24
 a3c:	70 f5       	brcc	.+92     	; 0xa9a <__vector_24+0x158>
        // copy data to output register and ack
        TWDR = twi_masterBuffer[twi_masterBufferIndex++];
 a3e:	e0 91 5c 02 	lds	r30, 0x025C	; 0x80025c <twi_masterBufferIndex>
 a42:	81 e0       	ldi	r24, 0x01	; 1
 a44:	8e 0f       	add	r24, r30
 a46:	80 93 5c 02 	sts	0x025C, r24	; 0x80025c <twi_masterBufferIndex>
 a4a:	f0 e0       	ldi	r31, 0x00	; 0
 a4c:	e3 5a       	subi	r30, 0xA3	; 163
 a4e:	fd 4f       	sbci	r31, 0xFD	; 253
 a50:	80 81       	ld	r24, Z
 a52:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
 a56:	85 ec       	ldi	r24, 0xC5	; 197
 a58:	83 c0       	rjmp	.+262    	; 0xb60 <__vector_24+0x21e>
    case TW_MT_SLA_NACK:  // address sent, nack received
      twi_error = TW_MT_SLA_NACK;
      twi_stop();
      break;
    case TW_MT_DATA_NACK: // data sent, nack received
      twi_error = TW_MT_DATA_NACK;
 a5a:	80 93 17 02 	sts	0x0217, r24	; 0x800217 <twi_error>
 a5e:	8b c0       	rjmp	.+278    	; 0xb76 <__vector_24+0x234>
      break;

    // Master Receiver
    case TW_MR_DATA_ACK: // data received, ack sent
      // put byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
 a60:	e0 91 5c 02 	lds	r30, 0x025C	; 0x80025c <twi_masterBufferIndex>
 a64:	81 e0       	ldi	r24, 0x01	; 1
 a66:	8e 0f       	add	r24, r30
 a68:	80 93 5c 02 	sts	0x025C, r24	; 0x80025c <twi_masterBufferIndex>
 a6c:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 a70:	f0 e0       	ldi	r31, 0x00	; 0
 a72:	e3 5a       	subi	r30, 0xA3	; 163
 a74:	fd 4f       	sbci	r31, 0xFD	; 253
 a76:	80 83       	st	Z, r24
    case TW_MR_SLA_ACK:  // address sent, ack received
      // ack if more bytes are expected, otherwise nack
      if(twi_masterBufferIndex < twi_masterBufferLength){
 a78:	90 91 5c 02 	lds	r25, 0x025C	; 0x80025c <twi_masterBufferIndex>
 a7c:	80 91 5b 02 	lds	r24, 0x025B	; 0x80025b <twi_masterBufferLength>
 a80:	6b c0       	rjmp	.+214    	; 0xb58 <__vector_24+0x216>
        twi_reply(0);
      }
      break;
    case TW_MR_DATA_NACK: // data received, nack sent
      // put final byte into buffer
      twi_masterBuffer[twi_masterBufferIndex++] = TWDR;
 a82:	e0 91 5c 02 	lds	r30, 0x025C	; 0x80025c <twi_masterBufferIndex>
 a86:	81 e0       	ldi	r24, 0x01	; 1
 a88:	8e 0f       	add	r24, r30
 a8a:	80 93 5c 02 	sts	0x025C, r24	; 0x80025c <twi_masterBufferIndex>
 a8e:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 a92:	f0 e0       	ldi	r31, 0x00	; 0
 a94:	e3 5a       	subi	r30, 0xA3	; 163
 a96:	fd 4f       	sbci	r31, 0xFD	; 253
 a98:	80 83       	st	Z, r24
	if (twi_sendStop)
 a9a:	80 91 82 02 	lds	r24, 0x0282	; 0x800282 <twi_sendStop>
 a9e:	81 11       	cpse	r24, r1
 aa0:	6a c0       	rjmp	.+212    	; 0xb76 <__vector_24+0x234>
          twi_stop();
	else {
	  twi_inRepStart = true;	// we're gonna send the START
 aa2:	81 e0       	ldi	r24, 0x01	; 1
 aa4:	80 93 81 02 	sts	0x0281, r24	; 0x800281 <twi_inRepStart>
	  // don't enable the interrupt. We'll generate the start, but we 
	  // avoid handling the interrupt until we're in the next transaction,
	  // at the point where we would normally issue the start.
	  TWCR = _BV(TWINT) | _BV(TWSTA)| _BV(TWEN) ;
 aa8:	84 ea       	ldi	r24, 0xA4	; 164
 aaa:	5e c0       	rjmp	.+188    	; 0xb68 <__vector_24+0x226>
    case TW_SR_SLA_ACK:   // addressed, returned ack
    case TW_SR_GCALL_ACK: // addressed generally, returned ack
    case TW_SR_ARB_LOST_SLA_ACK:   // lost arbitration, returned ack
    case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration, returned ack
      // enter slave receiver mode
      twi_state = TWI_SRX;
 aac:	83 e0       	ldi	r24, 0x03	; 3
 aae:	80 93 84 02 	sts	0x0284, r24	; 0x800284 <twi_state>
      // indicate that rx buffer can be overwritten and ack
      twi_rxBufferIndex = 0;
 ab2:	10 92 18 02 	sts	0x0218, r1	; 0x800218 <twi_rxBufferIndex>
 ab6:	cf cf       	rjmp	.-98     	; 0xa56 <__vector_24+0x114>
      twi_reply(1);
      break;
    case TW_SR_DATA_ACK:       // data received, returned ack
    case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
      // if there is still room in the rx buffer
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
 ab8:	80 91 18 02 	lds	r24, 0x0218	; 0x800218 <twi_rxBufferIndex>
 abc:	80 32       	cpi	r24, 0x20	; 32
 abe:	08 f0       	brcs	.+2      	; 0xac2 <__vector_24+0x180>
 ac0:	4e c0       	rjmp	.+156    	; 0xb5e <__vector_24+0x21c>
        // put byte in buffer and ack
        twi_rxBuffer[twi_rxBufferIndex++] = TWDR;
 ac2:	e0 91 18 02 	lds	r30, 0x0218	; 0x800218 <twi_rxBufferIndex>
 ac6:	81 e0       	ldi	r24, 0x01	; 1
 ac8:	8e 0f       	add	r24, r30
 aca:	80 93 18 02 	sts	0x0218, r24	; 0x800218 <twi_rxBufferIndex>
 ace:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
 ad2:	f0 e0       	ldi	r31, 0x00	; 0
 ad4:	e7 5e       	subi	r30, 0xE7	; 231
 ad6:	fd 4f       	sbci	r31, 0xFD	; 253
 ad8:	80 83       	st	Z, r24
 ada:	bd cf       	rjmp	.-134    	; 0xa56 <__vector_24+0x114>
        twi_reply(0);
      }
      break;
    case TW_SR_STOP: // stop or repeated start condition received
      // ack future responses and leave slave receiver state
      twi_releaseBus();
 adc:	0e 94 9b 04 	call	0x936	; 0x936 <twi_releaseBus>
      // put a null char after data if there's room
      if(twi_rxBufferIndex < TWI_BUFFER_LENGTH){
 ae0:	80 91 18 02 	lds	r24, 0x0218	; 0x800218 <twi_rxBufferIndex>
 ae4:	80 32       	cpi	r24, 0x20	; 32
 ae6:	30 f4       	brcc	.+12     	; 0xaf4 <__vector_24+0x1b2>
        twi_rxBuffer[twi_rxBufferIndex] = '\0';
 ae8:	e0 91 18 02 	lds	r30, 0x0218	; 0x800218 <twi_rxBufferIndex>
 aec:	f0 e0       	ldi	r31, 0x00	; 0
 aee:	e7 5e       	subi	r30, 0xE7	; 231
 af0:	fd 4f       	sbci	r31, 0xFD	; 253
 af2:	10 82       	st	Z, r1
      }
      // callback to user defined callback
      twi_onSlaveReceive(twi_rxBuffer, twi_rxBufferIndex);
 af4:	60 91 18 02 	lds	r22, 0x0218	; 0x800218 <twi_rxBufferIndex>
 af8:	70 e0       	ldi	r23, 0x00	; 0
 afa:	e0 91 7d 02 	lds	r30, 0x027D	; 0x80027d <twi_onSlaveReceive>
 afe:	f0 91 7e 02 	lds	r31, 0x027E	; 0x80027e <twi_onSlaveReceive+0x1>
 b02:	89 e1       	ldi	r24, 0x19	; 25
 b04:	92 e0       	ldi	r25, 0x02	; 2
 b06:	09 95       	icall
      // since we submit rx buffer to "wire" library, we can reset it
      twi_rxBufferIndex = 0;
 b08:	10 92 18 02 	sts	0x0218, r1	; 0x800218 <twi_rxBufferIndex>
      break;
 b0c:	36 c0       	rjmp	.+108    	; 0xb7a <__vector_24+0x238>
    
    // Slave Transmitter
    case TW_ST_SLA_ACK:          // addressed, returned ack
    case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
      // enter slave transmitter mode
      twi_state = TWI_STX;
 b0e:	84 e0       	ldi	r24, 0x04	; 4
 b10:	80 93 84 02 	sts	0x0284, r24	; 0x800284 <twi_state>
      // ready the tx buffer index for iteration
      twi_txBufferIndex = 0;
 b14:	10 92 3a 02 	sts	0x023A, r1	; 0x80023a <twi_txBufferIndex>
      // set tx buffer length to be zero, to verify if user changes it
      twi_txBufferLength = 0;
 b18:	10 92 39 02 	sts	0x0239, r1	; 0x800239 <twi_txBufferLength>
      // request for txBuffer to be filled and length to be set
      // note: user must call twi_transmit(bytes, length) to do this
      twi_onSlaveTransmit();
 b1c:	e0 91 7f 02 	lds	r30, 0x027F	; 0x80027f <twi_onSlaveTransmit>
 b20:	f0 91 80 02 	lds	r31, 0x0280	; 0x800280 <twi_onSlaveTransmit+0x1>
 b24:	09 95       	icall
      // if they didn't change buffer & length, initialize it
      if(0 == twi_txBufferLength){
 b26:	80 91 39 02 	lds	r24, 0x0239	; 0x800239 <twi_txBufferLength>
 b2a:	81 11       	cpse	r24, r1
 b2c:	05 c0       	rjmp	.+10     	; 0xb38 <__vector_24+0x1f6>
        twi_txBufferLength = 1;
 b2e:	81 e0       	ldi	r24, 0x01	; 1
 b30:	80 93 39 02 	sts	0x0239, r24	; 0x800239 <twi_txBufferLength>
        twi_txBuffer[0] = 0x00;
 b34:	10 92 3b 02 	sts	0x023B, r1	; 0x80023b <twi_txBuffer>
      }
      // transmit first byte from buffer, fall
    case TW_ST_DATA_ACK: // byte sent, ack returned
      // copy data to output register
      TWDR = twi_txBuffer[twi_txBufferIndex++];
 b38:	e0 91 3a 02 	lds	r30, 0x023A	; 0x80023a <twi_txBufferIndex>
 b3c:	81 e0       	ldi	r24, 0x01	; 1
 b3e:	8e 0f       	add	r24, r30
 b40:	80 93 3a 02 	sts	0x023A, r24	; 0x80023a <twi_txBufferIndex>
 b44:	f0 e0       	ldi	r31, 0x00	; 0
 b46:	e5 5c       	subi	r30, 0xC5	; 197
 b48:	fd 4f       	sbci	r31, 0xFD	; 253
 b4a:	80 81       	ld	r24, Z
 b4c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7e00bb>
      // if there is more to send, ack, otherwise nack
      if(twi_txBufferIndex < twi_txBufferLength){
 b50:	90 91 3a 02 	lds	r25, 0x023A	; 0x80023a <twi_txBufferIndex>
 b54:	80 91 39 02 	lds	r24, 0x0239	; 0x800239 <twi_txBufferLength>
 b58:	98 17       	cp	r25, r24
 b5a:	08 f4       	brcc	.+2      	; 0xb5e <__vector_24+0x21c>
 b5c:	7c cf       	rjmp	.-264    	; 0xa56 <__vector_24+0x114>
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
  }else{
	  TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
 b5e:	85 e8       	ldi	r24, 0x85	; 133
 b60:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
 b64:	0a c0       	rjmp	.+20     	; 0xb7a <__vector_24+0x238>
 */
void twi_reply(uint8_t ack)
{
  // transmit master read ready signal, with or without ack
  if(ack){
    TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
 b66:	85 ec       	ldi	r24, 0xC5	; 197
 b68:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7e00bc>
    case TW_ST_DATA_NACK: // received nack, we are done 
    case TW_ST_LAST_DATA: // received ack, but we are done already!
      // ack future responses
      twi_reply(1);
      // leave slave receiver state
      twi_state = TWI_READY;
 b6c:	10 92 84 02 	sts	0x0284, r1	; 0x800284 <twi_state>
      break;
 b70:	04 c0       	rjmp	.+8      	; 0xb7a <__vector_24+0x238>

    // All
    case TW_NO_INFO:   // no state information
      break;
    case TW_BUS_ERROR: // bus error, illegal stop/start
      twi_error = TW_BUS_ERROR;
 b72:	10 92 17 02 	sts	0x0217, r1	; 0x800217 <twi_error>
      twi_stop();
 b76:	0e 94 91 04 	call	0x922	; 0x922 <twi_stop>
      break;
  }
}
 b7a:	ff 91       	pop	r31
 b7c:	ef 91       	pop	r30
 b7e:	bf 91       	pop	r27
 b80:	af 91       	pop	r26
 b82:	9f 91       	pop	r25
 b84:	8f 91       	pop	r24
 b86:	7f 91       	pop	r23
 b88:	6f 91       	pop	r22
 b8a:	5f 91       	pop	r21
 b8c:	4f 91       	pop	r20
 b8e:	3f 91       	pop	r19
 b90:	2f 91       	pop	r18
 b92:	0f 90       	pop	r0
 b94:	0f be       	out	0x3f, r0	; 63
 b96:	0f 90       	pop	r0
 b98:	1f 90       	pop	r1
 b9a:	18 95       	reti

00000b9c <__tablejump2__>:
 b9c:	ee 0f       	add	r30, r30
 b9e:	ff 1f       	adc	r31, r31
 ba0:	05 90       	lpm	r0, Z+
 ba2:	f4 91       	lpm	r31, Z
 ba4:	e0 2d       	mov	r30, r0
 ba6:	09 94       	ijmp

00000ba8 <_exit>:
 ba8:	f8 94       	cli

00000baa <__stop_program>:
 baa:	ff cf       	rjmp	.-2      	; 0xbaa <__stop_program>
